{
  "hash": "a9a896efd470ac9b6c9007eac0ae4e13",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"1: Extract spatial data based on spatial point\"\n---\n\n\n\n## Introduction\nThis tutorial show how too extract spatial control variables based on surveys coordinate locations. The survey refers to Ethiopia 2019 and comes from the [The World Bank Living Standards Measurement Study (LSMS)](https://www.worldbank.org/en/programs/lsms). The spatial variables are nighttime light, agroecological zones, Urban-Rural Catchment Area, elevation, and climatic parameters. More information about these datasets are in the [Appendix].\n\n## Code\n### Set Up\nWe start by setting up the stage for our analysis.\nFirst, we load the necessary packages. We load only `climatic4economist` package that contains several functions meant to extract and merge spatial variables with surveys. During the tutorial we will use other packages but instead of loading all the package at the begging we will call specific function each time.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(climatic4economist)\n```\n:::\n\n\n\nIn the setup, we also want to create the paths to the various data sources and load the necessary functions for extraction. Note `..` means one step back to the folder directory, i.e. one folder back.\n\nNote that how to set up the paths depends on your folder organization but there are overall two approaches: \n\n1. you can use the `R project`, by opening the project directly you don't need to set up the path to the project. Automatically the project figures out on its own where it is located in the computer and set that path as working folder. \n2. you can manually set the working folder with the function `setwd()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# path to data folder\npath_to_data <- file.path(\"..\", # <1>\n                          \"..\", \"data\") # <2>\n\n# survey and administrative division\npath_to_survey  <- file.path(path_to_data, \"survey\", \"LSMS\", \"LSMS_ETH19.dta\")\npath_to_adm_div <- file.path(path_to_data, \"adm_div\", \"geoBoundaries\")\n\n# weather variables\npath_to_pre <- file.path(path_to_data, \"weather\", \"ERA5_Land\", \"AFR\", \"monthly\",\n                         \"afr_month_50_25_tpr.nc\")\npath_to_tmp <- file.path(path_to_data, \"weather\", \"ERA5_Land\", \"AFR\", \"monthly\",\n                         \"afr_month_50_25_tmp.nc\")\n\n# control variables\npath_to_elevation  <- file.path(path_to_data, \"spatial\", \"elevation\", \"GloFAS\",\n                               \"elevation_glofas_v4_0.nc\")\npath_to_urca       <- file.path(path_to_data, \"spatial\", \"URCA\", \n                               \"URCA.tif\")\npath_to_pop        <- file.path(path_to_data, \"spatial\", \"population\", \"WorldPop\",\n                               \"uncontraint_1km_global\", \"ppp_2019_1km_Aggregated.tif\")\npath_to_nightlight <- file.path(path_to_data, \"spatial\", \"nighttime_light\",\n                                \"VIIRS\", \"VNL_v21_npp_2019_global_vcmslcfg_c202205302300.average_masked.dat.tif\")\npath_to_aez        <- file.path(path_to_data, \"spatial\", \"AgroEcological\", \"AEZ\", \n                                \"GAEZv5\",  \"GAEZ-V5.AEZ33-10km.tif\")\n\n# to result folder\npath_to_result <- file.path(path_to_data, \"result\")\n```\n:::\n\n\n1. concatenate the string to make a path\n2. `..` means one folder back\n\n<br>\n\n### Read the Data\n#### Survey Data\nWe start by reading the surveys data. The survey is stored as `dta` file, so we use the `haven::read_dta()` function to read it. \n\nWe only need the `hhid`, the survey coordinates, and the interview dates. We use `dplyr::select()` to choose these variables. This passage is optional and we bring with us all the variables, but we won't use them.\n\nThen we create/modify some variables with the function `dplyr::mutate()`. We transform the the variable `interview_date` from string into data, and we get the year of the median value of the date of interviews. This passage is important as it allows us to define the most appropriate year to select for the spatial variables.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsrvy <- haven::read_dta(path_to_survey) |> # <1>\n    dplyr::select(survey_year, hhid, country, lat, lon, interview_date) |> # <2>\n    dplyr::mutate(\n        interview_date = clock::date_parse(interview_date, # <3>\n                                           format = \"%Y-%m-%d\"), # <4> \n        survey_year    = clock::get_year(median(interview_date)), # <5>\n        .before = hhid)\n```\n:::\n\n\n1. read dta type data\n2. select relevant variables\n3. transform string into date type\n4. specify format type\n5. find the median year of the interviews\n\n#### Spatial Data\nFinally, we load the spatial data. This data typically comes in the form of raster data. A raster represents a two-dimensional image as a rectangular matrix or grid of pixels. These are spatial rasters because they are georeferenced, meaning each pixel (or \"cell\" in GIS terms) represents a square region of geographic space. The value of each cell reflects a measurable property (either qualitative or quantitative) of that region.\n\nTo spatial data is usually stored as `tif` file or `nc`. We can read both of them them with the function `terra::rast()`.\n\nWhen we print the raster, we obtain several key details. The dimension tells us how many cells the raster consists of and the number of layers, each layer corresponds to a particular months for which the observations were made. We also get the spatial resolution, which defines the size of each square region in geographic space, and the coordinate reference system (CRS), i.e. `EPSG:4326`.\n\n::: {.callout-important}\nWhen working with multiple spatial data, you must ensure that they have the same coordinate reference system (CRS). This is important because in this way all the data can \"spatially\" talk to each other.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnightlight <- terra::rast(path_to_nightlight) |> # <1>\n  setNames(\"nightlight\") # <2>\nnightlight\n\nelevation <- terra::rast(path_to_elevation)\nelevation\n\nurca <- terra::rast(path_to_urca)\nurca\n\naez <- terra::rast(path_to_aez) |>\n    setNames(\"aez\") \naez\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \ndimensions  : 33601, 86401, 1  (nrow, ncol, nlyr)\nresolution  : 0.004166667, 0.004166667  (x, y)\nextent      : -180.0021, 180.0021, -65.00208, 75.00208  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : VNL_v21_npp_2019_global_vcmslcfg_c202205302300.average_masked.dat.tif \nname        : nightlight \nclass       : SpatRaster \ndimensions  : 3000, 7200, 1  (nrow, ncol, nlyr)\nresolution  : 0.05, 0.05  (x, y)\nextent      : -180, 180, -60, 90  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 \nsource      : elevation_glofas_v4_0.nc \nvarname     : elevation (Height above sea level) \nname        : elevation \nunit        :         m \nclass       : SpatRaster \ndimensions  : 17235, 43200, 1  (nrow, ncol, nlyr)\nresolution  : 0.008333333, 0.008333333  (x, y)\nextent      : -180, 180, -60, 83.625  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : URCA.tif \nname        : URCA \nclass       : SpatRaster \ndimensions  : 2160, 4320, 1  (nrow, ncol, nlyr)\nresolution  : 0.08333333, 0.08333333  (x, y)\nextent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : GAEZ-V5.AEZ33-10km.tif \nname        : aez \n```\n\n\n:::\n:::\n\n\n1. read raster type data\n2. change the name of the layer\n\nNow we also read the weather observation. The same consideration about the coordinate reference system (CRS) is still valid. When we work with raster that have also observations over time, it is important to check how and where the time and date information is stored. \nSometimes it is stored in the metadata and you can access it using `terra::time()`, other time it is already saved as the name of the layer and you can access it using `names()`.\nSometimes, like in this case the date information is stored in the names but the format is based on second passed from `1970-01-01 00:00`. To transform this observation into readable date we can use the function `second_to_date()`.\n\n::: {.callout-warning}\nNote that rasters can store time information in different ways, so it may not always be possible to retrieve dates in this manner. A common alternative is for dates to be embedded in the layer names, in which case we wouldnâ€™t need to rename the layers.\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npre <- terra::rast(path_to_pre)\npre\nnames(pre) <- terra::names(pre) |> second_to_date() # <1>\npre\n\ntmp <- terra::rast(path_to_tmp)\nnames(tmp) <- terra::names(tmp) |> second_to_date() # <1>\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nclass       : SpatRaster \ndimensions  : 741, 811, 904  (nrow, ncol, nlyr)\nresolution  : 0.1, 0.1  (x, y)\nextent      : -26.05, 55.05, -36.05, 38.05  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 \nsource      : afr_month_50_25_tpr.nc:tp \nvarname     : tp (Total precipitation) \nnames       : tp_va~52000, tp_va~73600, tp_va~54400, tp_va~76000, tp_va~84000, tp_va~05600, ... \nunit        :           m,           m,           m,           m,           m,           m, ... \nclass       : SpatRaster \ndimensions  : 741, 811, 904  (nrow, ncol, nlyr)\nresolution  : 0.1, 0.1  (x, y)\nextent      : -26.05, 55.05, -36.05, 38.05  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 \nsource      : afr_month_50_25_tpr.nc:tp \nvarname     : tp (Total precipitation) \nnames       : 1950-01-01, 1950-02-01, 1950-03-01, 1950-04-01, 1950-05-01, 1950-06-01, ... \nunit        :          m,          m,          m,          m,          m,          m, ... \n```\n\n\n:::\n:::\n\n\n1. transform the layers name with second into dates\n\n#### Administrative Boundaries\nWe now move to read the administrative divisions. We use the function `read_geoBoundaries()` to do so. This function looks for spatial polygons for the `iso` and `lvl` provided provided.\n\nAs we have the coordinates, we don't actually need the administrative divisions for the extraction. However, we will use it to reduce the coverage of the spatial variables and to make some plots.\n\nThe same consideration about the coordinate reference system (CRS) is still valid.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nadm_div <- read_geoBoundaries(path_to_adm_div, iso = \"ETH\", lvl = 2)\nadm_div\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n class       : SpatVector \n geometry    : polygons \n dimensions  : 74, 4  (geometries, attributes)\n extent      : 33.00224, 47.95925, 3.400365, 14.84602  (xmin, xmax, ymin, ymax)\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       : ID_adm_div   iso adm_div_1 adm_div_2\n type        :      <chr> <chr>     <chr>     <chr>\n values      :          1   ETH    Somali     Afder\n                        2   ETH   Gambela    Agnuak\n                        3   ETH     SNNPR     Alaba\n```\n\n\n:::\n:::\n\n\n\n<br>\n\n### Georeference the Surveys\nAs we've mentioned, the spatial data is georeferenced, so we need to ensure the same for the survey data. \nSince many households share the same coordinates, they are linked to the same location. To reduce computation time, we extract data only for the unique coordinates, rather than for each household. Moreover, we must ensure that we can later associate the correct weather data with the right household, we do this by creating an merging variable called `ID`.\n\nThis is handled by the `prepare_coord()` function, which requires the coordinates' variable names as input.\n\nOnce we have the unique coordinates, we are ready to transform them into spatial points using the `georef_coord()` function. When performing this transformation, it's crucial to set the correct CRS, which must match that of the weather data. The CRS is provided as an argument of the function, using the previously saved CRS from the weather data. Also the `georef_coord()` function requires the coordinates' variable names as input.\nUsually, the WGS 84 CRS is the default coordinate references system for coordinates. In this case it  matches the weather coordinate references system.\n\nWe can print the result to check the transformation. The new column, `ID`, is created by `prepare_coord()` and identifies each unique coordinate. This is used to merge the weather data with the household data.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsrvy_coord <- prepare_coord(srvy,\n                            lon_var = lon,\n                            lat_var = lat)\nsrvy_coord\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6,505 Ã— 7\n   ID    survey_year hhid               country    lat   lon interview_date\n   <chr>       <int> <chr>              <chr>    <dbl> <dbl> <date>        \n 1 1            2019 051103088801903002 Ethiopia  3.61  39.0 2019-08-28    \n 2 1            2019 051103088801903012 Ethiopia  3.61  39.0 2019-08-28    \n 3 1            2019 051103088801903022 Ethiopia  3.61  39.0 2019-08-28    \n 4 1            2019 051103088801903032 Ethiopia  3.61  39.0 2019-08-29    \n 5 1            2019 051103088801903042 Ethiopia  3.61  39.0 2019-08-29    \n 6 1            2019 051103088801903052 Ethiopia  3.61  39.0 2019-08-28    \n 7 1            2019 051103088801903062 Ethiopia  3.61  39.0 2019-08-28    \n 8 1            2019 051103088801903072 Ethiopia  3.61  39.0 2019-08-28    \n 9 1            2019 051103088801903082 Ethiopia  3.61  39.0 2019-08-28    \n10 1            2019 051103088801903092 Ethiopia  3.61  39.0 2019-08-29    \n# â„¹ 6,495 more rows\n```\n\n\n:::\n:::\n\n\n\nOnce we have the unique coordinates, we are ready to transform them into spatial points using the `georef_coord()` function. When performing this transformation, it's crucial to set the correct CRS, which must match that of the weather data. The function also the coordinates' variable names as input.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsrvy_geo <- georef_coord(srvy_coord,\n                         geom = c(\"lon\", \"lat\"),\n                         crs = \"EPSG:4326\")\nsrvy_geo\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n class       : SpatVector \n geometry    : points \n dimensions  : 516, 1  (geometries, attributes)\n extent      : 33.43483, 47.30784, 3.609384, 14.47715  (xmin, xmax, ymin, ymax)\n coord. ref. : lon/lat WGS 84 (EPSG:4326) \n names       :    ID\n type        : <chr>\n values      :     1\n                   2\n                   3\n```\n\n\n:::\n:::\n\n\n\n::: {.callout-note}\nPay attention on the reduced number of observation between `srvy_coord` and `srvy_geo`. From 6505 rows to 516, these are the actual unique locations from the survey.\n:::\n\n<br>\n\n### Crop the spatial variables\nThe spatial variables variables we have just load have a global coverage. It might be convenient to reduce the coverage to just the countries we are interested in. We can do this by using the `crop_with_buffer()` function and the administrative divisions. As the name suggest, this function allows to specify a buffer around the vector data to increase the spatial extent and crop a larger portion. This is useful as some survey coordinates are at the edge of the administrative borders or, in some rare cases, just outside the borders as consequence of the coordinates modification fro location anonymization. Further, to compute some spatial indicators in one cell we need the surrounding cell values and if we crop exactly at the borders those cell values at the edge won't have the he surrounding cells.\n\nThe `buffer` argument of the function specifies the increase around the spatial extent. By default, it is in the same unit of measure of the data.\n\nThis is not a compulsory step but it reduce the memory burden and allows for more meaningful plotting.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnghtlght_cntry <- crop_with_buffer(nightlight, adm_div, buffer = 1)\n\nelevatn_cntry <- crop_with_buffer(elevation, adm_div, buffer = 1)\n\nurca_cntry <- crop_with_buffer(urca, adm_div, buffer = 1)\n\naez_cntry <- crop_with_buffer(aez, adm_div, buffer = 1)\n\npre_cntry <- crop_with_buffer(pre, adm_div, buffer = 1)\n\ntmp_cntry <- crop_with_buffer(tmp, adm_div, buffer = 1)\n```\n:::\n\n\n\n<br>\n\n### Plot\n\nA good practice when working with spatial data is to plot it. This is the best way to verify that everything is working as expected.\n\nFirst, we plot the survey coordinates to ensure they are correctly located within the country and to examine their spatial distribution.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nterra::plot(adm_div, col = \"grey\", main = \"District of Ethiopia and Survey Coordinates\") # <1>\nterra::points(srvy_geo, col = \"red\", alpha = 0.5, cex = 0.5) # <2>\n```\n\n::: {.cell-output-display}\n![](extract_by_point_files/figure-html/plot_survey_geo-1.png){width=672}\n:::\n:::\n\n\n1. plot raster\n2. add survey locations\n\nWe confirm that the survey locations are within the country borders, which is great! We also observe that the spatial distribution of survey coordinates is neither random nor uniform; most are concentrated near the major cities and in the North.\n\nNext, we plot the spatial variables to see how it overlaps with the spatial coordinates.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nterra::plot(elevatn_cntry, main = \"Elevation\") # <1>\nterra::lines(adm_div, col = \"white\", lwd = 1) # <2>\nterra::points(srvy_geo, col = \"red\", alpha = 0.5, cex = 0.5) # <3>\n```\n\n::: {.cell-output-display}\n![](extract_by_point_files/figure-html/plot_sp_var-1.png){width=672}\n:::\n\n```{.r .cell-code}\nterra::plot(urca_cntry, main = \"URCA\")\nterra::lines(adm_div, col = \"black\", lwd = 2)\nterra::points(srvy_geo, col = \"red\", alpha = 1, cex = 0.6)\n```\n\n::: {.cell-output-display}\n![](extract_by_point_files/figure-html/plot_sp_var-2.png){width=672}\n:::\n\n```{.r .cell-code}\nterra::plot(log(1+nghtlght_cntry), main = \"Log Nighttime Light\")\nterra::lines(adm_div, col = \"white\", lwd = 1)\nterra::points(srvy_geo, col = \"red\", alpha = 1, cex = 0.6)\n```\n\n::: {.cell-output-display}\n![](extract_by_point_files/figure-html/plot_sp_var-3.png){width=672}\n:::\n\n```{.r .cell-code}\nterra::plot(tmp_cntry, \"2024-03-01\", col = terra::map.pal(\"water\"),\n            main = \"Monthly precipitation at 2024-03 and survey location\")\nterra::lines(adm_div, col = \"white\", lwd = 1)\nterra::points(srvy_geo, col = \"red\", alpha = 0.5, cex = 0.5)\n```\n\n::: {.cell-output-display}\n![](extract_by_point_files/figure-html/plot_sp_var-4.png){width=672}\n:::\n\n```{.r .cell-code}\nterra::plot(tmp_cntry, \"2024-03-01\", col = terra::map.pal(\"ryb\"),\n            main = \"Monthly temperature at 2024-03 and survey location\")\nterra::lines(adm_div, col = \"white\", lwd = 1)\nterra::points(srvy_geo, col = \"black\", alpha = 0.5, cex = 0.5)\n```\n\n::: {.cell-output-display}\n![](extract_by_point_files/figure-html/plot_sp_var-5.png){width=672}\n:::\n:::\n\n\n1. plot raster\n2. add administrative borders\n3. add survey locations\n\nOnce again, the survey coordinates align with the precipitation data, which is great! We can also observe the different spatial resolution, with precipitation having a lower one. The consequence is that some survey coordinates still fall within the same cell.\n\n<br>\n\n### Modify the Spatial Variables\n#### Compute Terrain Indicators\nNow we compute some terrain indicators based on elevation. The terrain indicators are:\n\n* TRI (Terrain Ruggedness Index) is the mean of the absolute differences between the value of a cell and its 8 surrounding cells.\n\n* Slope is the average difference between the value of a cell and its 8 surrounding cells.\n\n* Roughness is the difference between the maximum and the minimum value of a cell and its 8 surrounding cells.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nterrain_cntry <-  terra::terrain(elevatn_cntry,\n                                 v = c(\"slope\", \"TRI\", \"roughness\"), # <1>\n                                 neighbors = 8, #<2>\n                                 unit = \"degrees\")\n```\n:::\n\n\n1. the terrain indicators\n2. how many neighboring cells, 8 (queen case) or 4 (rook case)\n\n#### Weather Variable Transformation\nThe original unit of measure of the weather data is in meter for precipitation and Kelvin for temperature. These unit of measure are not very intuitive, therefore we change them into millimeter and Celsius respectively.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# From meter to millimeters\npre_cntry_mm <- pre_cntry*1000\n\n# From Kelvin to Celsius\ntmp_cntry_c <- tmp_cntry - 273.15\n```\n:::\n\n\n\n<br>\n\n### Extraction\nNext, we extract the spatial data based on the survey coordinates using the `extract_by_coord()` function. This function requires the raster with the spatial data and the georeferenced coordinates as inputs.\n\nLooking at the result, we see first the `ID` column, that identifies the unique survey coordinates. The second and third column are the coordinates of the cells. The other columns contain the spatial observations, specific to each coordinate. For the weather data we have the time series of observations over time, specific to each coordinate.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnghtlght_coord <- extract_by_coord(nghtlght_cntry, srvy_geo)\nnghtlght_coord\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 516 Ã— 4\n   ID    x_cell y_cell nightlight\n   <chr>  <dbl>  <dbl>      <dbl>\n 1 1       39.0   3.61      0    \n 2 2       41.8   4.01      0    \n 3 3       41.9   4.44      0    \n 4 4       41.5   4.73      0    \n 5 5       36.0   4.75      0    \n 6 6       38.1   4.85      0    \n 7 7       37.4   4.97      0    \n 8 8       40.7   5.11      0.816\n 9 9       41.9   5.15      0    \n10 10      44.6   5.24      0    \n# â„¹ 506 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\nelevation_coord <- extract_by_coord(elevatn_cntry, srvy_geo)\n\nterrain_coord <- extract_by_coord(terrain_cntry, srvy_geo)\n\nurca_coord <- extract_by_coord(urca_cntry, srvy_geo)\n\naez_coord <- extract_by_coord(aez_cntry, srvy_geo)\n\npre_coord <- extract_by_coord(pre_cntry, srvy_geo)\n\ntmp_coord <- extract_by_coord(tmp_cntry, srvy_geo)\ntmp_coord\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 516 Ã— 907\n   ID    x_cell y_cell X1950_01_01 X1950_02_01 X1950_03_01 X1950_04_01\n   <chr>  <dbl>  <dbl>       <dbl>       <dbl>       <dbl>       <dbl>\n 1 1       39     3.60        296.        298.        295.        294.\n 2 2       41.8   4.00        303.        304.        300.        299.\n 3 3       41.9   4.40        303.        304.        300.        299.\n 4 4       41.5   4.7         301.        302.        299.        298.\n 5 5       36     4.7         301.        304.        300.        299.\n 6 6       38.1   4.8         293.        295.        292.        292.\n 7 7       37.4   5.00        294.        296.        293.        292.\n 8 8       40.7   5.1         296.        298.        295.        294.\n 9 9       41.9   5.1         303.        303.        300.        298.\n10 10      44.6   5.2         301.        302.        301.        300.\n# â„¹ 506 more rows\n# â„¹ 900 more variables: X1950_05_01 <dbl>, X1950_06_01 <dbl>,\n#   X1950_07_01 <dbl>, X1950_08_01 <dbl>, X1950_09_01 <dbl>, X1950_10_01 <dbl>,\n#   X1950_11_01 <dbl>, X1950_12_01 <dbl>, X1951_01_01 <dbl>, X1951_02_01 <dbl>,\n#   X1951_03_01 <dbl>, X1951_04_01 <dbl>, X1951_05_01 <dbl>, X1951_06_01 <dbl>,\n#   X1951_07_01 <dbl>, X1951_08_01 <dbl>, X1951_09_01 <dbl>, X1951_10_01 <dbl>,\n#   X1951_11_01 <dbl>, X1951_12_01 <dbl>, X1952_01_01 <dbl>, â€¦\n```\n\n\n:::\n:::\n\n\n\nAgain we have a row for each unique location from the survey. However, if we want to know how many different cells there are we can look unique cell coordinates.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique_cell <- tmp_coord |>\n  dplyr::distinct(x_cell, y_cell) # <1>\nnrow(unique_cell)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 365\n```\n\n\n:::\n:::\n\n\n1. identifies the unique combination of the variables\n\n::: {.callout-note}\nWe see that now the number of rows is 365, this is the actual different weather observations that we can merge with the survey. We start with 6505 different household, then we have 516 different survey coordinates, and we end up with 365 different weather observations.\n:::\n\n<br>\n\n### Cmpute Long Run Climatic Parameter\nWe want to describe the long run climatic condition in each locations. Rule of thumb is to use 30 years of weather observations to capture climatic features. Therefore, we select the 30 years before each survey.\n\nCheck the names with the date of observations and how it has changed since before.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\npre_coord_30yrs <- select_by_dates(pre_coord, from = \"1989\", to = \"2019\")\ntmp_coord_30yrs <- select_by_dates(tmp_coord, from = \"1989\", to = \"2019\")\n\ntmp_coord_30yrs\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 516 Ã— 364\n   ID    x_cell y_cell X1989_01_01 X1989_02_01 X1989_03_01 X1989_04_01\n   <chr>  <dbl>  <dbl>       <dbl>       <dbl>       <dbl>       <dbl>\n 1 1       39     3.60        297.        297.        297.        294.\n 2 2       41.8   4.00        303.        304.        303.        300.\n 3 3       41.9   4.40        303.        304.        303.        300.\n 4 4       41.5   4.7         301.        301.        301.        299.\n 5 5       36     4.7         303.        303.        304.        302.\n 6 6       38.1   4.8         294.        295.        294.        292.\n 7 7       37.4   5.00        296.        296.        296.        294.\n 8 8       40.7   5.1         297.        297.        297.        295.\n 9 9       41.9   5.1         303.        303.        303.        300.\n10 10      44.6   5.2         301.        301.        303.        302.\n# â„¹ 506 more rows\n# â„¹ 357 more variables: X1989_05_01 <dbl>, X1989_06_01 <dbl>,\n#   X1989_07_01 <dbl>, X1989_08_01 <dbl>, X1989_09_01 <dbl>, X1989_10_01 <dbl>,\n#   X1989_11_01 <dbl>, X1989_12_01 <dbl>, X1990_01_01 <dbl>, X1990_02_01 <dbl>,\n#   X1990_03_01 <dbl>, X1990_04_01 <dbl>, X1990_05_01 <dbl>, X1990_06_01 <dbl>,\n#   X1990_07_01 <dbl>, X1990_08_01 <dbl>, X1990_09_01 <dbl>, X1990_10_01 <dbl>,\n#   X1990_11_01 <dbl>, X1990_12_01 <dbl>, X1991_01_01 <dbl>, â€¦\n```\n\n\n:::\n:::\n\n\n\nNow we can compute the long run climatic parameter. We calculate the mean, the standard deviation, and the coefficient of variation. We collect all the parameter in a separate object `parameter`. This object is a names list of functions and we construct it with this structure `name = function`, then the `list()` function puts them together. This passage is not compulsory but allows to perform the computation of multiple parameters in a tidy and efficient way. Otherwise we could have directly add them inside the `calc_par()`.\n\nThe function `calc_par()` calculates the required parameters.\n\nThe results have a similar structure, with the first columns that identify the specific locations and the other the computed parameters. Note how we are still carrying on the `coverage_fraction` variable as we will need it for aggregating the climatic parameter at the administrative division.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparameter <- list(std = sd, avg = mean, coef_var = cv)\nparameter\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$std\nfunction (x, na.rm = FALSE) \nsqrt(var(if (is.vector(x) || is.factor(x)) x else as.double(x), \n    na.rm = na.rm))\n<bytecode: 0x11238b0e0>\n<environment: namespace:stats>\n\n$avg\nfunction (x, ...) \nUseMethod(\"mean\")\n<bytecode: 0x110554970>\n<environment: namespace:base>\n\n$coef_var\nfunction(x, na_rm = TRUE) {\n    avg <- mean(x, na.rm = na_rm)\n    if (is.nan(avg)) return(NA_real_)\n    if (avg == 0) return(NA_real_)  # Avoid division by zero\n    sd(x, na.rm = na_rm) / mean(x, na.rm = na_rm)\n}\n<bytecode: 0x1123820b0>\n<environment: namespace:climatic4economist>\n```\n\n\n:::\n\n```{.r .cell-code}\npre_par_coord <- calc_par(pre_coord_30yrs, pars = parameter, prefix = \"pre\")\ntmp_par_coord <- calc_par(tmp_coord_30yrs, pars = parameter, prefix = \"tmp\")\ntmp_par_coord\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 516 Ã— 6\n   ID    x_cell y_cell tmp_std tmp_avg tmp_coef_var\n   <chr>  <dbl>  <dbl>   <dbl>   <dbl>        <dbl>\n 1 1       39     3.60    1.71    295.      0.00580\n 2 10      44.6   5.2     1.05    302.      0.00347\n 3 100     37.9   7.5     1.35    290.      0.00464\n 4 101     45     7.5     1.17    298.      0.00392\n 5 102     36.8   7.6     1.31    291.      0.00449\n 6 103     34.3   7.7     2.45    302.      0.00811\n 7 104     38.3   7.7     1.41    292.      0.00481\n 8 105     34.1   7.7     2.45    302.      0.00812\n 9 106     37.4   7.7     1.79    293.      0.00613\n10 107     37.5   7.8     1.55    291.      0.00534\n# â„¹ 506 more rows\n```\n\n\n:::\n:::\n\n\n\n<br>\n\n### Merge with Survey\nNow that we have everything, we can combine all the extracted data and then merge them with the survey.\nWe start by combining the data into a unique data set. To do so we start by create a list with the function `list()`, each element of the list is a different spatial variable.\n\nWe need to drop the cell coordinates. This because, the cell resolution is different among the spatial datasets, despite the same CRS, and thus the coordinates of the cells are slightly different among datasets. This impinges the merge and at this stage of the analysis we don't need the information they are carrying anymore.\n\nTo drop them requires a convoluted approach, but it takes advantage that all the datasets are grouped in the same list and the procedure is the same for each dataset. To apply a function to each element of a list we can use the function `purrr::map()`. As arguments, this function requires the function we want to apply, namely `dplyr::select`, and additional arguments for the function, `-c(x_cell, y_cell)` which are the columns we want to to drop. Note the minus symbol as it tells the function we want to drop the columns and not keep them.\n\nThen we combine the elements of the list with the function `purrr::reduce()`. This last function require another function as input to drive the combination and we choose to use `merge_by_common()`, which merges two data by their common variable names.\n\nWhy not using directly `merge_by_common()`? Because the function works with just two datasets and we have eight different spatial datasets. We can cumulatively merge the datasets one by one or we can use the `purrr::reduce()`. \n\nThen we compute the logarithmic transformation of the nighttime light, with the `dplyr::mutate()` function.  We use the argument `.after` to specify where the position of the variable.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsptl_coord <- list(nghtlght_coord, # <1>\n                   terrain_coord, \n                   elevation_coord, \n                   urca_coord, \n                   aez_coord, \n                   pre_par_coord, \n                   tmp_par_coord) |>\n    purrr::map(dplyr::select, -c(x_cell, y_cell)) |> # <2>\n    purrr::reduce(merge_by_common) |> # <3>\n    dplyr::mutate(ln_nightlight = log(1+nightlight), .after = nightlight) # <4>\nsptl_coord\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 516 Ã— 15\n   ID    nightlight ln_nightlight  slope    TRI roughness elevation  URCA   aez\n   <chr>      <dbl>         <dbl>  <dbl>  <dbl>     <dbl>     <dbl> <int> <int>\n 1 1          0             0     0.394   37.7     138.       1140.    13     1\n 2 2          0             0     0.274   23.7      67.0       249.    19    26\n 3 3          0             0     0.0540  16.3      38.1       196.    12    26\n 4 4          0             0     0.961   73.5     215.        466.    30    26\n 5 5          0             0     0.0237   1.94      7.63      369.    13    29\n 6 6          0             0     2.10   195.      619.       1838.    12    26\n 7 7          0             0     0.939   81.4     252.       1514.    19     1\n 8 8          0.816         0.597 0.625   42.6     155.       1215.     5     1\n 9 9          0             0     0.264   18.2      60.9       281.    12    26\n10 10         0             0     0.512   38.3     149.        241.    20    29\n# â„¹ 506 more rows\n# â„¹ 6 more variables: pre_std <dbl>, pre_avg <dbl>, pre_coef_var <dbl>,\n#   tmp_std <dbl>, tmp_avg <dbl>, tmp_coef_var <dbl>\n```\n\n\n:::\n:::\n\n\n1. combine the data into a list\n2. remove variables from each element of the list\n3. merge all the elements of the list\n4. create new variable\n\nNow that we have all the control variables together, we can merge them with the surveys information. The function `merge_by_common()` will do it for us.\n\nWe can see that the result has all the information we retained from the surveys and the new extracted spatial variables.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsrvy_sptl_coord <- merge_by_common(srvy_coord, sptl_coord)\nsrvy_sptl_coord\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6,505 Ã— 21\n   ID    survey_year hhid          country   lat   lon interview_date nightlight\n   <chr>       <int> <chr>         <chr>   <dbl> <dbl> <date>              <dbl>\n 1 1            2019 051103088801â€¦ Ethiopâ€¦  3.61  39.0 2019-08-28              0\n 2 1            2019 051103088801â€¦ Ethiopâ€¦  3.61  39.0 2019-08-28              0\n 3 1            2019 051103088801â€¦ Ethiopâ€¦  3.61  39.0 2019-08-28              0\n 4 1            2019 051103088801â€¦ Ethiopâ€¦  3.61  39.0 2019-08-29              0\n 5 1            2019 051103088801â€¦ Ethiopâ€¦  3.61  39.0 2019-08-29              0\n 6 1            2019 051103088801â€¦ Ethiopâ€¦  3.61  39.0 2019-08-28              0\n 7 1            2019 051103088801â€¦ Ethiopâ€¦  3.61  39.0 2019-08-28              0\n 8 1            2019 051103088801â€¦ Ethiopâ€¦  3.61  39.0 2019-08-28              0\n 9 1            2019 051103088801â€¦ Ethiopâ€¦  3.61  39.0 2019-08-28              0\n10 1            2019 051103088801â€¦ Ethiopâ€¦  3.61  39.0 2019-08-29              0\n# â„¹ 6,495 more rows\n# â„¹ 13 more variables: ln_nightlight <dbl>, slope <dbl>, TRI <dbl>,\n#   roughness <dbl>, elevation <dbl>, URCA <int>, aez <int>, pre_std <dbl>,\n#   pre_avg <dbl>, pre_coef_var <dbl>, tmp_std <dbl>, tmp_avg <dbl>,\n#   tmp_coef_var <dbl>\n```\n\n\n:::\n:::\n\n\n\n<br>\n\n### Write\nHere we are at the end, let's save the results. We want to save the result as `dta` so we will use the `haven::write_dta()` function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhaven::write_dta(srvy_sptl_coord,\n                 file.path(path_to_result, \"ETH_sp_coord.dta\"))\n```\n:::\n\n\n\n<br><br>\n\n\n## Take home messages\n\n* When working with multiple spatial data:\n  \n  1. remember to control the Coordinate Reference System of all dataset\n  2. plot the data to check everything is going well\n  \n* based on the typology of data we use different function to read them\n    * for `dta` use `haven::read_dta() or` and `haven::_write_dta()`\n    * for spatial vectors `read_GAUL()` for administrative divisions in specific country and level, otherwise `terra::vect()`\n    * for spatial raster use `terra::rast()`\n\n* Extraction\n    * since many household share the same locations, we take advantage of this by extracting the weather data only at the unique locations, we achieve this with the function `prepare_coord()`.\n    * same of these unique locations may fall within the same value cells, so the actual information might be even lower.\n\n* When working with raster data\n\n  1. check the unit of measure\n  2. if it is a time series check also the date format\n  \n* When working with survey and time series data, remember to select the appropriate observations, for example not those that happened after the interview.\n  \n<br><br>\n\n## Appendix\n### Want to know about the data?\n#### Weather\nWeather observation are obtained from ERA5-Land reanalysis dataset. H-TESSEL is the land surface model that is the basis of ERA5-Land. The data is a post-processed monthly-mean average of the original ERA5-Land dataset.\n\n| Parameter           | Value                   |\n|:--------------------|:-----------------------:|\n| spatial resolution  | 0.1Â° x 0.1Â° lon lat     |\n| temporal resolution | month                   |\n| time frame          | Jan. 1950 - Dec. 2022   |\n| unit of measure     | meter or Kelvin         |\n\nSuggested citation:\n\n* MuÃ±oz Sabater, J. (2019): ERA5-Land monthly averaged data from 1950 to present. Copernicus Climate Change Service (C3S) Climate Data Store (CDS). DOI: 10.24381/cds.68d2bb30\n\nIt is possible to find additional information: \n\n* [here](https://cds.climate.copernicus.eu/cdsapp#!/dataset/reanalysis-era5-land-monthly-means?tab=overview) \n* and the related manual [here](https://confluence.ecmwf.int/display/CKB/ERA5-Land). \n\nThe data can be freely download from \n\n* [here](https://cds.climate.copernicus.eu/cdsapp#!/dataset/reanalysis-era5-land-monthly-means?tab=overview).\n\n\n###### Total precipitation\nAccumulated liquid and frozen water, including rain and snow, that falls to the Earth's surface. It is the sum of large-scale precipitation and convective precipitation. Precipitation variables do not include fog, dew or the precipitation that evaporates in the atmosphere before it lands at the surface of the Earth.\n\n###### 2 metre above ground temperature\nTemperature of air at 2m above the surface of land, sea or in-land waters. 2m temperature is calculated by interpolating between the lowest model level and the Earth's surface, taking account of the atmospheric conditions.\n\n<br>\n\n#### Spatial variables \n##### Agro Ecological Zones\nThe Agro-ecological Zones classification (33 classes) provides a characterization of bio-physical resources relevant to agricultural production systems. AEZ definitions and map classes follow a rigorous methodology and an explicit set of principles. The inventory combines spatial layers of thermal and moisture regimes with broad categories of soil/terrain qualities. It also indicates locations of areas with irrigated soils and shows land with severely limiting bio-physical constraints including very cold and very dry (desert) areas as well as areas with very steep terrain or very poor soil/terrain conditions.\nThe AEZ classification dataset is part of the GAEZ v5 Land and Water Resources theme and Agro-ecological Zones sub-theme. All results are derived from the Agro-ecological Zones (AEZ) modeling framework, developed collaboratively by the Food and Agriculture Organization (FAO) and the International Institute for Applied Systems Analysis (IIASA). \n\n| Parameter           | Value                                                  |\n|:--------------------|:------------------------------------------------------:|\n| spatial resolution  | 10 km.                                                 |\n| temporal resolution | 20 years                                               |\n| time frame          | 2001â€“2020                                              |\n| unit of measure     | classification by climate/soil/terrain/LC (33 classes) |\n\nSuggested citation:\n\n* FAO & IIASA. 2025. Global Agro-ecological Zoning version 5 (GAEZ v5) Model Documentation. https://github.com/un-fao/gaezv5/wiki\n\n\nIt is possible to find additional information:\n\n* [here](https://github.com/un-fao/gaezv5/wiki). \n\nThe data can be freely download from:\n\n* [here](https://data.apps.fao.org/catalog/iso/2c09f61b-801c-47d2-a989-0abd3500a365).\n\n<br>\n\n##### Urban-Rural Catchment Area (URCA)\n\nUrbanâ€“rural catchment areas showing the catchment areas around cities and towns of different sizes (the no data value is 128). Each rural pixel is assigned to one defined travel time category to one of seven urban agglomeration sizes.\n\n| Parameter           | Value                                             |\n|:--------------------|:-------------------------------------------------:|\n| spatial resolution  | 0.03Â° x 0.03Â° lon lat                             |\n| temporal resolution | year                                              |\n| time frame          | 2015                                              |\n| unit of measure     | travel time category to different urban hierarchy |\n\n\nSuggested citation:\n\n* Cattaneo, Andrea; Nelson, Andy; McMenomy, Theresa (2020). Urban-rural continuum. figshare. Dataset. https://doi.org/10.6084/m9.figshare.12579572.v4\n\nIt is possible to find additional information:\n\n* [here](https://www.pnas.org/doi/full/10.1073/pnas.2011990118). \n\n\nThe data can be freely download from:\n\n* [here](https://figshare.com/articles/dataset/Urban-rural_continuum/12579572).\n\n<br>\n\n##### Population\nThe units are number of people per pixel. The mapping approach is Random Forest-based dasymetric redistribution.\n\n| Parameter           | Value                                   |\n|:--------------------|:---------------------------------------:|\n| spatial resolution  | 30 arc second (~1km)                    |\n| temporal resolution | year                                    |\n| time frame          | 2010 - 2020                             |\n| unit of measure     | estimated count of people per grid-cell |\n\nSuggested citation:\n\n*\tWorldPop (www.worldpop.org - School of Geography and Environmental Science, University of Southampton; Department of Geography and Geosciences, University of Louisville; Departement de Geographie, Universite de Namur) and Center for International Earth Science Information Network (CIESIN), Columbia University (2018). Global High Resolution Population Denominators Project - Funded by The Bill and Melinda Gates Foundation (OPP1134076). https://dx.doi.org/10.5258/SOTON/WP00647 \n\nIt is possible to find additional information from:\n\n* [here](https://www.worldpop.org/methods/top_down_constrained_vs_unconstrained/)\n* [here](https://www.worldpop.org/methods/populations/). \n\nThe data can be freely download from:\n\n* [here](https://hub.worldpop.org/geodata/summary?id=34984).\n\n<br>\n\n##### Nighttime light\n\nVIIRS nighttime lights (VNL) version V2.1: annual values obtained by from the monthly averages with filtering to remove extraneous features such as biomass burning, aurora, and background.\n\n| Parameter           | Value                       |\n|:--------------------|:---------------------------:|\n| spatial resolution  | 15 arc second               |\n| temporal resolution | year                        |\n| time frame          | 2012 - 2021                 |\n| unit of measure     | nW/cm2/sr, average-masked   |\n\nSuggested citation:\n\n* Elvidge, C.D, Zhizhin, M., Ghosh T., Hsu FC, Taneja J. Annual time series of global VIIRS nighttime lights derived from monthly averages:2012 to 2019. Remote Sensing 2021, 13(5), p.922, doi:10.3390/rs13050922\n\nIt is possible to find additional information:\n\n* [here](https://eogdata.mines.edu/products/vnl/). \n\nThe data can be freely download from:\n\n* [here](https://eogdata.mines.edu/nighttime_light/annual/v21/).\n\n<br>\n\n##### Elevation\nThe Global Flood Awareness System (GloFAS) is one component of the Copernicus Emergency Management Service (CEMS). It is designed to support preparatory measures for flood events worldwide, particularly in large transnational river basins.\n\nElevation is obtained from the auxiliary variables of GloFAS. Each pixel is the mean height elevation above sea level.\n\n| Parameter           | Value                       |\n|:--------------------|:---------------------------:|\n| spatial resolution  |\t0.03Â° x 0.03Â° lon lat       |\n| temporal resolution | 30 years                    |\n| time frame          | 1981 - 2010                 |\n| unit of measure     | Meter (m)                   |\n\n\nWeb resources:\n\n* [here](https://www.globalfloods.eu/technical-information/products/)\n\nData access:\n\n* [here](https://confluence.ecmwf.int/display/CEMS/Auxiliary+Data)\n\n<br>\n\n#### Survey\n\nThe Living Standards Measurement Study - Integrated Surveys on Agriculture (LSMS-ISA) is a unique system of longitudinal surveys designed to improve the understanding of household and individual welfare, livelihoods and smallholder agriculture in Africa. The LSMS team works with national statistics offices to design and implement household surveys with a strong focus on agriculture.\n\nSuggested citation:\n\n* Central Statistics Agency of Ethiopia. (2020). Socioeconomic Survey 2018-2019 [Data set]. World Bank, Development Data Group. https://doi.org/10.48529/K739-C548\n\nIt is possible to find additional information:\n\n* [here](https://www.worldbank.org/en/programs/lsms). \n\nThe data can be freely download from:\n\n* [here](https://microdata.worldbank.org/index.php/home).\n\n<br>\n\n#### Administrative boundaries\n\nThe administrative divisions are obtained from GeoBoundaries[^2]. GeoBoundaries Built by the community and William & Mary geoLab, the geoBoundaries Global Database of Political Administrative Boundaries Database is an online, open license (CC BY 4.0) resource of information on administrative boundaries (i.e., state, county) for every country in the world. Since 2016, we have tracked approximately 1 million boundaries within over 200 entities, including all UN member states.\n\nSuggested citation:\n\n* Runfola D, Anderson A, Baier H, Crittenden M, Dowker E, Fuhrig S, et al. (2020) geoBoundaries: A global database of political administrative boundaries. PLoS ONE 15(4): e0231866. https://doi.org/10.1371/journal.pone.0231866.\n\nIt is possible to find additional information:\n\n* [here](https://www.geoboundaries.org/countryDownloads.html). \n\nThe data can be freely download from:\n\n* [here](https://www.geoboundaries.org).\n\n\n\n\n",
    "supporting": [
      "extract_by_point_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}