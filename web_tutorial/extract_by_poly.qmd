---
title: "2: Extract spatial data based on spatial polygons"
---

## Introduction
This tutorial show how too extract spatial control variables based on surveys administrative divisions. The survey refers to Ethiopia 2019 and comes from the [The World Bank Living Standards Measurement Study (LSMS)](https://www.worldbank.org/en/programs/lsms). The spatial variables are nighttime light, agroecological zones, Urban-Rural Catchment Area, elevation, and climatic parameters. More information about these datasets are in the [Appendix].

<br>

## Code
### Set Up
We start by setting up the stage for our analysis.
First, we load the necessary packages. We load only `climatic4economist` package that contains several functions meant to extract and merge spatial variables with surveys. During the tutorial we will use other packages but instead of loading all the package at the begging we will call specific function each time.

```{r packages}
#| label: packages
#| output: false

library(climatic4economist)
```

In the setup, we also want to create the paths to the various data sources and load the necessary functions for extraction. Note `..` means one step back to the folder directory, i.e. one folder back.

Note that how to set up the paths depends on your folder organization but there are overall two approaches: 

1. you can use the `R project`, by opening the project directly you don't need to set up the path to the project. Automatically the project figures out on its own where it is located in the computer and set that path as working folder. 
2. you can manually set the working folder with the function `setwd()`.

```{r paths}
#| label: paths

# path to data folder
path_to_data <- file.path("..", # <1>
                          "..", "data") # <2>

# survey and administrative division
path_to_survey  <- file.path(path_to_data, "survey", "LSMS", "LSMS_ETH19.dta")
path_to_adm_div <- file.path(path_to_data, "adm_div", "geoBoundaries")

# weather variables
path_to_pre <- file.path(path_to_data, "weather", "ERA5_Land", "AFR", "monthly",
                         "afr_month_50_25_tpr.nc")
path_to_tmp <- file.path(path_to_data, "weather", "ERA5_Land", "AFR", "monthly",
                         "afr_month_50_25_tmp.nc")

# control variables
path_to_elevation  <- file.path(path_to_data, "spatial", "elevation", "GloFAS",
                               "elevation_glofas_v4_0.nc")
path_to_urca       <- file.path(path_to_data, "spatial", "URCA", 
                               "URCA.tif")
path_to_pop        <- file.path(path_to_data, "spatial", "population", "WorldPop",
                               "uncontraint_1km_global", "ppp_2019_1km_Aggregated.tif")
path_to_nightlight <- file.path(path_to_data, "spatial", "nighttime_light",
                                "VIIRS", "VNL_v21_npp_2019_global_vcmslcfg_c202205302300.average_masked.dat.tif")
path_to_aez        <- file.path(path_to_data, "spatial", "AgroEcological", "AEZ", 
                                "GAEZv5",  "GAEZ-V5.AEZ33-10km.tif")

# to result folder
path_to_result <- file.path(path_to_data, "result")
```
1. concatenate the string to make a path
2. `..` means one folder back

<br>

### Read the Data
#### Survey Data
We start by reading the surveys data. The survey is stored as `dta` file, so we use the `haven::read_dta()` function to read it. 

We only need the `hhid`, the survey coordinates, and the interview dates. We use `dplyr::select()` to choose these variables. This passage is optional and we bring with us all the variables, but we won't use them.

Then we create/modify some variables with the function `dplyr::mutate()`. We transform the the variable `interview_date` from string into data, and we get the year of the median value of the date of interviews. This passage is important as it allows us to define the most appropriate year to select for the spatial variables.

```{r read_srvy}
#| label: read_srvy

srvy <- haven::read_dta(path_to_survey) |> # <1>
    dplyr::select(survey_year, hhid, country, lat, lon, interview_date) |> # <2>
    dplyr::mutate(
        interview_date = clock::date_parse(interview_date, # <3>
                                           format = "%Y-%m-%d"), # <4> 
        survey_year    = clock::get_year(median(interview_date)), # <5>
        .before = hhid)

```
1. read dta type data
2. select relevant variables
3. transform string into date type
4. specify format type
5. find the median year of the interviews

#### Spatial Data
Finally, we load the spatial data. This data typically comes in the form of raster data. A raster represents a two-dimensional image as a rectangular matrix or grid of pixels. These are spatial rasters because they are georeferenced, meaning each pixel (or "cell" in GIS terms) represents a square region of geographic space. The value of each cell reflects a measurable property (either qualitative or quantitative) of that region.

To spatial data is usually stored as `tif` file or `nc`. We can read both of them them with the function `terra::rast()`.

When we print the raster, we obtain several key details. The dimension tells us how many cells the raster consists of and the number of layers, each layer corresponds to a particular months for which the observations were made. We also get the spatial resolution, which defines the size of each square region in geographic space, and the coordinate reference system (CRS), i.e. `EPSG:4326`.

::: {.callout-important}
When working with multiple spatial data, you must ensure that they have the same coordinate reference system (CRS). This is important because in this way all the data can "spatially" talk to each other.
:::

```{r read_spatial}
#| label: read_spatial

pop <- terra::rast(path_to_pop) |> # <1>
  setNames("pop") # <2>
pop

nightlight <- terra::rast(path_to_nightlight) |>
  setNames("nightlight")
nightlight

elevation <- terra::rast(path_to_elevation)
elevation

urca <- terra::rast(path_to_urca)
urca

aez <- terra::rast(path_to_aez) |>
    setNames("aez") 
aez

```
1. read raster type data
2. change the name of the layer

Now we also read the weather observation. The same consideration about the coordinate reference system (CRS) is still valid. When we work with raster that have also observations over time, it is important to check how and where the time and date information is stored. 
Sometimes it is stored in the metadata and you can access it using `terra::time()`, other time it is already saved as the name of the layer and you can access it using `names()`.
Sometimes, like in this case the date information is stored in the names but the format is based on second passed from `1970-01-01 00:00`. To transform this observation into readable date we can use the function `second_to_date()`.

::: {.callout-warning}
Note that rasters can store time information in different ways, so it may not always be possible to retrieve dates in this manner. A common alternative is for dates to be embedded in the layer names, in which case we wouldn’t need to rename the layers.
:::

```{r read_weather}
#| label: read_weather
pre <- terra::rast(path_to_pre)
pre
names(pre) <- terra::names(pre) |> second_to_date() # <1>
pre

tmp <- terra::rast(path_to_tmp)
names(tmp) <- terra::names(tmp) |> second_to_date() # <1>
```
1. transform the layers name with second into dates

#### Administrative Boundaries
We now move to read the administrative divisions. We use the function `read_geoBoundaries()` to do so. This function looks for spatial polygons for the `iso` and `lvl` provided provided.

As we have the coordinates, we don't actually need the administrative divisions for the extraction. However, we will use it to reduce the coverage of the spatial variables and to make some plots.

The same consideration about the coordinate reference system (CRS) is still valid.

```{r read_adm_div}
#| label: read_adm_div

adm_div <- read_geoBoundaries(path_to_adm_div, iso = "ETH", lvl = 2)
adm_div
```

<br>

### Georeference the Surveys
As we've mentioned, the spatial data is georeferenced, so we need to ensure the same for the survey data. We use the spatial coordinates to assign the administrative division to each household.
We must ensure that we can later associate the correct weather data with the right household, we do this by creating an merging variable called `ID`.

This is handled by the `prepare_coord()` function, which requires the coordinates' variable names as input.

Once we have the unique coordinates, we are ready to transform them into spatial points using the `georef_coord()` function. When performing this transformation, it's crucial to set the correct CRS, which must match that of the weather data. The CRS is provided as an argument of the function, using the previously saved CRS from the weather data. Also the `georef_coord()` function requires the coordinates' variable names as input.
Usually, the WGS 84 CRS is the default coordinate references system for coordinates. In this case it  matches the weather coordinate references system.

We can print the result to check the transformation. The new column, `ID`, is created by `prepare_coord()` and identifies each unique coordinate. This is used to merge the weather data with the household data.

```{r prepare_coord}
#| label: prepare_coord

srvy_coord <- prepare_coord(srvy,
                            lon_var = lon,
                            lat_var = lat)
srvy_coord
```

Once we have the unique coordinates, we are ready to transform them into spatial points using the `georef_coord()` function. When performing this transformation, it's crucial to set the correct CRS, which must match that of the weather data. The function also the coordinates' variable names as input.

```{r georef_coord}
#| label: georef_coord

srvy_geo <- georef_coord(srvy_coord,
                         geom = c("lon", "lat"),
                         crs = "EPSG:4326")
srvy_geo
```

<br>

### Merge administrative division and survey
We want to associated the survey location to the administrative divisions. We do it by looking in which administrative division each survey location fall in. We save this information for later use.

```{r merge_adm_srvy}
#| label: merge_adm_srvy

srvy_adm_div <- get_poly_attr_for_point(srvy_geo, adm_div)
srvy_adm_div
```

<br>

### Crop the spatial variables
The spatial variables variables we have just load have a global coverage. It might be convenient to reduce the coverage to just the countries we are interested in. We can do this by using the `crop_with_buffer()` function and the administrative divisions. As the name suggest, this function allows to specify a buffer around the vector data to increase the spatial extent and crop a larger portion. This is useful as some survey coordinates are at the edge of the administrative borders or, in some rare cases, just outside the borders as consequence of the coordinates modification fro location anonymization. Further, to compute some spatial indicators in one cell we need the surrounding cell values and if we crop exactly at the borders those cell values at the edge won't have the he surrounding cells.

The `buffer` argument of the function specifies the increase around the spatial extent. By default, it is in the same unit of measure of the data.

This is not a compulsory step but it reduce the memory burden and allows for more meaningful plotting.

```{r crop}
#| label: crop

pop_cntry <- crop_with_buffer(pop, adm_div, buffer = 1)

nghtlght_cntry <- crop_with_buffer(nightlight, adm_div, buffer = 1)

elevatn_cntry <- crop_with_buffer(elevation, adm_div, buffer = 1)

urca_cntry <- crop_with_buffer(urca, adm_div, buffer = 1)

aez_cntry <- crop_with_buffer(aez, adm_div, buffer = 1)

pre_cntry <- crop_with_buffer(pre, adm_div, buffer = 1)

tmp_cntry <- crop_with_buffer(tmp, adm_div, buffer = 1)

```

<br>

### Plot

A good practice when working with spatial data is to plot it. This is the best way to verify that everything is working as expected.

First, we plot the survey coordinates to ensure they are correctly located within the country and to examine their spatial distribution.

```{r plot_survey_geo}
#| label: plot_survey_geo

terra::plot(adm_div, col = "grey", main = "District of Ethiopia and Survey Coordinates") # <1>
terra::points(srvy_geo, col = "red", alpha = 0.5, cex = 0.5) # <2>

```
1. plot raster
2. add survey locations

We confirm that the survey locations are within the country borders, which is great! We also observe that the spatial distribution of survey coordinates is neither random nor uniform; most are concentrated near the major cities and in the North.

Next, we plot the spatial variables to see how it overlaps with the spatial coordinates.

```{r plot_sp_var}
#| label: plot_sp_var

terra::plot(elevatn_cntry, main = "Elevation") # <1>
terra::lines(adm_div, col = "white", lwd = 1) # <2>
terra::points(srvy_geo, col = "red", alpha = 0.5, cex = 0.5) # <3>

terra::plot(log(1+pop_cntry), main = "Log Population")
terra::lines(adm_div, col = "white", lwd = 1)
terra::points(srvy_geo, col = "red", alpha = 0.5, cex = 0.5)

terra::plot(urca_cntry, main = "URCA")
terra::lines(adm_div, col = "black", lwd = 2)
terra::points(srvy_geo, col = "red", alpha = 1, cex = 0.6)

terra::plot(log(1+nghtlght_cntry), main = "Log Nighttime Light")
terra::lines(adm_div, col = "white", lwd = 1)
terra::points(srvy_geo, col = "red", alpha = 1, cex = 0.6)

terra::plot(tmp_cntry, "2024-03-01", col = terra::map.pal("water"),
            main = "Monthly precipitation at 2024-03 and survey location")
terra::lines(adm_div, col = "white", lwd = 1)
terra::points(srvy_geo, col = "red", alpha = 0.5, cex = 0.5)

terra::plot(tmp_cntry, "2024-03-01", col = terra::map.pal("ryb"),
            main = "Monthly temperature at 2024-03 and survey location")
terra::lines(adm_div, col = "white", lwd = 1)
terra::points(srvy_geo, col = "black", alpha = 0.5, cex = 0.5)
```
1. plot raster
2. add administrative borders
3. add survey locations

Once again, the survey coordinates align with the precipitation data, which is great! We can also observe the different spatial resolution, with precipitation having a lower one. The consequence is that some survey coordinates still fall within the same cell.

<br>

### Modify the Spatial Variables
#### Compute Terrain Indicators
Now we compute some terrain indicators based on elevation. The terrain indicators are:

* TRI (Terrain Ruggedness Index) is the mean of the absolute differences between the value of a cell and its 8 surrounding cells.

* Slope is the average difference between the value of a cell and its 8 surrounding cells.

* Roughness is the difference between the maximum and the minimum value of a cell and its 8 surrounding cells.

```{r terrain_indicator}
#| label: terrain_indicator

terrain_cntry <-  terra::terrain(elevatn_cntry,
                                 v = c("slope", "TRI", "roughness"), # <1>
                                 neighbors = 8, #<2>
                                 unit = "degrees")

nghtlght_cntry$ln_nightlight <- log(1 + nghtlght_cntry)
```
1. the terrain indicators
2. how many neighboring cells, 8 (queen case) or 4 (rook case)

#### Weather Variable Transformation
The original unit of measure of the weather data is in meter for precipitation and Kelvin for temperature. These unit of measure are not very intuitive, therefore we change them into millimeter and Celsius respectively.

```{r transformation}
#| label: transformation

# From meter to millimeters
pre_cntry_mm <- pre_cntry*1000

# From Kelvin to Celsius
tmp_cntry_c <- tmp_cntry - 273.15
```

<br>

#### Compute the Surface Area of the Administrative Divisons
We now compute the surface are of each administrative division. We will use it for computing the population density. We use the function `dplyr::mutate()` to add the variable `area_km` and the function `terra::expanse()` to compute the surface area.

```{r compute_area}
#| label: compute_area

adm_div_area <- adm_div |>
    dplyr::mutate(area_km = terra::expanse(adm_div, unit = "km"))
```

<br>


### Extraction
#### Spatial Variables
We extract the spatial data based on the administrative division  using the `extract_by_poly()` function. This function requires the raster with the spatial data, the administrative division, and the aggregation function as input. The aggregation function, `fn_agg`, defines how the cell values that fall within an administrative division are combined into a single value. Note that by default all the cell values are weighted by the coverage area of the cell that fall within the division.

Contrary to the other spatial variable, for population we use `adm_div_area` to extract the values as we need the surface area to calculate the population density.

Looking at the result, we see first the `ID_adm_div` column, that identifies the unique administrative divisions. The second to fourth column are the additional information coming from the administrative division data. The last column contain the spatial observations aggregated at the administrative division.

```{r extraction_adm}
#| label: extraction_adm

pop_adm <- extract_by_poly(pop_cntry, adm_div_area, fn_agg = "sum")
pop_adm

nghtlght_adm <- extract_by_poly(nghtlght_cntry, adm_div, fn_agg = "mean")

elevation_adm <- extract_by_poly(elevatn_cntry, adm_div, fn_agg = "mean")

terrain_adm <- extract_by_poly(terrain_cntry, adm_div, fn_agg = "mean")

urca_adm <- extract_by_poly(urca_cntry, adm_div, fn_agg = "modal")

aez_adm <- extract_by_poly(aez_cntry, adm_div, fn_agg = "modal")

aez_adm
```

#### Weather Variables
Fro weather data, we use a different function for extracting the data, namely `extract_cell_by_poly()`. Contrary to the function `extract_by_poly()`, this doesn't aggregate the values within the polygons but extract each all the cell values within the division separately. This is important as we want to compute the long run climatic parameter for cell and only later aggregate them.

::: {.callout-note}
To extract each cells is more computationally and memory demanding, especially with large countries and long time series, but it increases precision as the aggregation, thus lost of information, is done at very last stage of the process.
:::

Looking at the result, we see first the `ID_adm_div` column, that identifies the unique administrative divisions. The second and third column are the coordinates of the cells. The fourth is the amount of the cell that actually falls within the administrative division. The other columns contain the weather observations over time specific to each cell.

```{r extraction_adm_weather}
#| label: extraction_adm_weather
#| output: false

pre_cell <- extract_cell_by_poly(pre_cntry_mm, adm_div)

tmp_cell <- extract_cell_by_poly(tmp_cntry_c, adm_div)
```

```{r print_tmp_cell}
#| label: print_tmp_cell

tmp_cell
```

<br>


### Cmpute Long Run Climatic Parameter
We want to describe the long run climatic condition in each locations. Rule of thumb is to use 30 years of weather observations to capture climatic features. Therefore, we select the 30 years before each survey.

Check the names with the date of observations and how it has changed since before.

```{r select_by_dates}
#| label: select_by_dates

pre_cell_30yrs <- select_by_dates(pre_cell, from = "1989", to = "2019" )
tmp_cell_30yrs <- select_by_dates(tmp_cell, from = "1989", to = "2019")
tmp_cell_30yrs
```

Now we can compute the long run climatic parameter. We calculate the mean, the standard deviation, and the coefficient of variation. We collect all the parameter in a separate object `parameter`. This object is a names list of functions and we construct it with this structure `name = function`, then the `list()` function puts them together. This passage is not compulsory but allows to perform the computation of multiple parameters in a tidy and efficient way. Otherwise we could have directly add them inside the `calc_par()`.

The function `calc_par()` calculates the required parameters.

The results have a similar structure, with the first columns that identify the specific locations and the other the computed parameters. Note how we are still carrying on the `coverage_fraction` variable as we will need it for aggregating the climatic parameter at the administrative division.

```{r cal_parameter}
#| label: cal_parameter

parameter <- list(std = sd, avg = mean, coef_var = cv)
parameter

pre_par_cell <- calc_par(pre_cell_30yrs, pars = parameter, prefix = "pre")
tmp_par_cell <- calc_par(tmp_cell_30yrs, pars = parameter, prefix = "tmp")

tmp_par_cell
```

We have computed the climatic parameters for each cells but we still need to aggregate them at the administrative divisions. The function `agg_to_adm_div()` can do it for us, be aware the the function aggregate by using the weighted mean, where the weights are provided by the `coverage_fraction` variable.

In the results we lose the the information on the specific cells and we are left only with the administrative division id, `ID_adm_div`, and a single value of the climatic parameters for each locations.

```{r cell_to_div}
#| label: cell_to_div

pre_par_adm <- agg_to_adm_div(pre_par_cell , match_col = "pre")
tmp_par_adm <- agg_to_adm_div(tmp_par_cell, match_col = "tmp")

tmp_par_adm
```

<br>

### Merge with Survey
Now that we have everything, we can combine all the extracted data and then merge them with the survey.
We start by combining the data into a unique data set. To do so we start by create a list with the function `list()`, each element of the list is a different spatial variable and then we combine the elements of the list with the function `purrr::reduce()`. This last function require another function as input to drive the combination and we choose to use `merge_by_common()`, which merges two data by their common variable names.

Why not using directly `merge_by_common()`? Because the function works with just two datasets and we have eight different spatial datasets. We can cumulatively merge the datasets one by one or we can use the `purrr::reduce()`. 

Then we compute also the population density and the logarithmic transformation of the nighttime light. We use the `dplyr::mutate()` function to add these two new variables. We use the argument `.after` to specify where the position of the variable among the columns.

```{r combine_adm_spt}
#| label: combine_adm_spt

sptl_adm <- list(pop_adm, # <1>
                 nghtlght_adm,
                 terrain_adm, 
                 elevation_adm, 
                 urca_adm, 
                 aez_adm, 
                 pre_par_adm, 
                 tmp_par_adm) |>
    purrr::reduce(merge_by_common) |> # <2>
    dplyr::mutate(pop_density = pop/area_km, .after = pop) # <3>

sptl_adm
```
1. combine the data into a list
2. merge all the elements of the list
3. create new variables

Now that we have all the control variables together, we can merge them with the surveys information. The function `merge_by_common()` will do it for us.

However, the surveys do not carry information on the administrative division we have used, therefore we need an additional step to provide this information. We calculated this link information before and save it as `srvy_adm_div`.

We first merge the link information with the spatial extracted variables, the output is then merge with the survey. Note that the pipe command `|>` assumes that the left side is the first argument in the function, as it is not the case for us we need to specify it with `y = _`, where `y` is the name of the argument and `_` refer to the previous merge.

We can see that the result has all the information we retained from the surveys, the information about the administrative divisions, and the new extracted spatial variables.

```{r merge_adm_survey}
#| label: merge_adm_survey
 
srvy_sptl_adm <- merge_by_common(srvy_adm_div, sptl_adm) |> # <1>
    merge_by_common(srvy_coord, y = _) # <2>
srvy_sptl_adm
```
1. merge adm info with spatial var
2. `_` refers to the output of the previous merge 

<br>

### Write
Here we are at the end, let's save the results. We want to save the result as `dta` so we will use the `haven::write_dta()` function.

```{r write}
#| label: write
#| eval: false

haven::write_dta(srvy_sptl_adm,
                 file.path(path_to_result, "ETH_sp_adm.dta"))
```

<br><br>

## Take home messages

* When working with multiple spatial data:
  
  1. remember to control the Coordinate Reference System of all dataset
  2. plot the data to check everything is going well
  
* based on the typology of data we use different function
  
  - reading
    * for `dta` use `haven::read_dta() or` and `haven::_write_dta()`
    * for spatial vectors use `terra::vect()` or `read_adm_div()` for administrative divisions in specific country and level.
    * for spatial raster use `terra::rast()`
    
  - extraction
    
    * spatial points, use `extract_by_coord()`
    * spatial polygons, use `extract_by_poly()`
    * cells within polygons, use `extract_cell_by_poly()`
    
* When working with raster data

  1. check the unit of measure
  2. if it is a time series check also the date format
    
* When working with spatial polygons, like administrative divisions valuate if you want to extract the values already aggregated or each cells separately
  * for example the terrain indicators were computed for each cells and then we moved to the extraction
  * for the climatic parameters, we extract each cells separately, we compute the parameters for each cells, and only later we aggregate them.

* When georeferencing the survey location we take advantage that many interviews share the same locations. Hence, we extract the variables just for these unique locations. However, same of these unique locations may fall within the same value cells, so the actual information might be even lower.
  
<br><br>
  

## Appendix
### Want to know about the data?
#### Weather
Weather observation are obtained from ERA5-Land reanalysis dataset. H-TESSEL is the land surface model that is the basis of ERA5-Land. The data is a post-processed monthly-mean average of the original ERA5-Land dataset.

| Parameter           | Value                   |
|:--------------------|:-----------------------:|
| spatial resolution  | 0.1° x 0.1° lon lat     |
| temporal resolution | month                   |
| time frame          | Jan. 1950 - Dec. 2022   |
| unit of measure     | meter or Kelvin         |

Suggested citation:

* Muñoz Sabater, J. (2019): ERA5-Land monthly averaged data from 1950 to present. Copernicus Climate Change Service (C3S) Climate Data Store (CDS). DOI: 10.24381/cds.68d2bb30

It is possible to find additional information: 

* [here](https://cds.climate.copernicus.eu/cdsapp#!/dataset/reanalysis-era5-land-monthly-means?tab=overview) 
* and the related manual [here](https://confluence.ecmwf.int/display/CKB/ERA5-Land). 

The data can be freely download from 

* [here](https://cds.climate.copernicus.eu/cdsapp#!/dataset/reanalysis-era5-land-monthly-means?tab=overview).


###### Total precipitation
Accumulated liquid and frozen water, including rain and snow, that falls to the Earth's surface. It is the sum of large-scale precipitation and convective precipitation. Precipitation variables do not include fog, dew or the precipitation that evaporates in the atmosphere before it lands at the surface of the Earth.

###### 2 metre above ground temperature
Temperature of air at 2m above the surface of land, sea or in-land waters. 2m temperature is calculated by interpolating between the lowest model level and the Earth's surface, taking account of the atmospheric conditions.

<br>

#### Spatial variables 
##### Agro Ecological Zones
The Agro-ecological Zones classification (33 classes) provides a characterization of bio-physical resources relevant to agricultural production systems. AEZ definitions and map classes follow a rigorous methodology and an explicit set of principles. The inventory combines spatial layers of thermal and moisture regimes with broad categories of soil/terrain qualities. It also indicates locations of areas with irrigated soils and shows land with severely limiting bio-physical constraints including very cold and very dry (desert) areas as well as areas with very steep terrain or very poor soil/terrain conditions.
The AEZ classification dataset is part of the GAEZ v5 Land and Water Resources theme and Agro-ecological Zones sub-theme. All results are derived from the Agro-ecological Zones (AEZ) modeling framework, developed collaboratively by the Food and Agriculture Organization (FAO) and the International Institute for Applied Systems Analysis (IIASA). 

| Parameter           | Value                                                  |
|:--------------------|:------------------------------------------------------:|
| spatial resolution  | 10 km.                                                 |
| temporal resolution | 20 years                                               |
| time frame          | 2001–2020                                              |
| unit of measure     | classification by climate/soil/terrain/LC (33 classes) |

Suggested citation:

* FAO & IIASA. 2025. Global Agro-ecological Zoning version 5 (GAEZ v5) Model Documentation. https://github.com/un-fao/gaezv5/wiki


It is possible to find additional information:

* [here](https://github.com/un-fao/gaezv5/wiki). 

The data can be freely download from:

* [here](https://data.apps.fao.org/catalog/iso/2c09f61b-801c-47d2-a989-0abd3500a365).

<br>

##### Urban-Rural Catchment Area (URCA)

Urban–rural catchment areas showing the catchment areas around cities and towns of different sizes (the no data value is 128). Each rural pixel is assigned to one defined travel time category to one of seven urban agglomeration sizes.

| Parameter           | Value                                             |
|:--------------------|:-------------------------------------------------:|
| spatial resolution  | 0.03° x 0.03° lon lat                             |
| temporal resolution | year                                              |
| time frame          | 2015                                              |
| unit of measure     | travel time category to different urban hierarchy |


Suggested citation:

* Cattaneo, Andrea; Nelson, Andy; McMenomy, Theresa (2020). Urban-rural continuum. figshare. Dataset. https://doi.org/10.6084/m9.figshare.12579572.v4

It is possible to find additional information:

* [here](https://www.pnas.org/doi/full/10.1073/pnas.2011990118). 


The data can be freely download from:

* [here](https://figshare.com/articles/dataset/Urban-rural_continuum/12579572).

<br>

##### Population
The units are number of people per pixel. The mapping approach is Random Forest-based dasymetric redistribution.

| Parameter           | Value                                   |
|:--------------------|:---------------------------------------:|
| spatial resolution  | 30 arc second (~1km)                    |
| temporal resolution | year                                    |
| time frame          | 2010 - 2020                             |
| unit of measure     | estimated count of people per grid-cell |

Suggested citation:

*	WorldPop (www.worldpop.org - School of Geography and Environmental Science, University of Southampton; Department of Geography and Geosciences, University of Louisville; Departement de Geographie, Universite de Namur) and Center for International Earth Science Information Network (CIESIN), Columbia University (2018). Global High Resolution Population Denominators Project - Funded by The Bill and Melinda Gates Foundation (OPP1134076). https://dx.doi.org/10.5258/SOTON/WP00647 

It is possible to find additional information from:

* [here](https://www.worldpop.org/methods/top_down_constrained_vs_unconstrained/)
* [here](https://www.worldpop.org/methods/populations/). 

The data can be freely download from:

* [here](https://hub.worldpop.org/geodata/summary?id=34984).

<br>

##### Nighttime light

VIIRS nighttime lights (VNL) version V2.1: annual values obtained by from the monthly averages with filtering to remove extraneous features such as biomass burning, aurora, and background.

| Parameter           | Value                       |
|:--------------------|:---------------------------:|
| spatial resolution  | 15 arc second               |
| temporal resolution | year                        |
| time frame          | 2012 - 2021                 |
| unit of measure     | nW/cm2/sr, average-masked   |

Suggested citation:

* Elvidge, C.D, Zhizhin, M., Ghosh T., Hsu FC, Taneja J. Annual time series of global VIIRS nighttime lights derived from monthly averages:2012 to 2019. Remote Sensing 2021, 13(5), p.922, doi:10.3390/rs13050922

It is possible to find additional information:

* [here](https://eogdata.mines.edu/products/vnl/). 

The data can be freely download from:

* [here](https://eogdata.mines.edu/nighttime_light/annual/v21/).

<br>

##### Elevation
The Global Flood Awareness System (GloFAS) is one component of the Copernicus Emergency Management Service (CEMS). It is designed to support preparatory measures for flood events worldwide, particularly in large transnational river basins.

Elevation is obtained from the auxiliary variables of GloFAS. Each pixel is the mean height elevation above sea level.

| Parameter           | Value                       |
|:--------------------|:---------------------------:|
| spatial resolution  |	0.03° x 0.03° lon lat       |
| temporal resolution | 30 years                    |
| time frame          | 1981 - 2010                 |
| unit of measure     | Meter (m)                   |


Web resources:

* [here](https://www.globalfloods.eu/technical-information/products/)

Data access:

* [here](https://confluence.ecmwf.int/display/CEMS/Auxiliary+Data)

<br>

#### Survey

The Living Standards Measurement Study - Integrated Surveys on Agriculture (LSMS-ISA) is a unique system of longitudinal surveys designed to improve the understanding of household and individual welfare, livelihoods and smallholder agriculture in Africa. The LSMS team works with national statistics offices to design and implement household surveys with a strong focus on agriculture.

Suggested citation:

* Central Statistics Agency of Ethiopia. (2020). Socioeconomic Survey 2018-2019 [Data set]. World Bank, Development Data Group. https://doi.org/10.48529/K739-C548

It is possible to find additional information:

* [here](https://www.worldbank.org/en/programs/lsms). 

The data can be freely download from:

* [here](https://microdata.worldbank.org/index.php/home).

<br>

#### Administrative boundaries

The administrative divisions are obtained from GeoBoundaries[^2]. GeoBoundaries Built by the community and William & Mary geoLab, the geoBoundaries Global Database of Political Administrative Boundaries Database is an online, open license (CC BY 4.0) resource of information on administrative boundaries (i.e., state, county) for every country in the world. Since 2016, we have tracked approximately 1 million boundaries within over 200 entities, including all UN member states.

Suggested citation:

* Runfola D, Anderson A, Baier H, Crittenden M, Dowker E, Fuhrig S, et al. (2020) geoBoundaries: A global database of political administrative boundaries. PLoS ONE 15(4): e0231866. https://doi.org/10.1371/journal.pone.0231866.

It is possible to find additional information:

* [here](https://www.geoboundaries.org/countryDownloads.html). 

The data can be freely download from:

* [here](https://www.geoboundaries.org).

