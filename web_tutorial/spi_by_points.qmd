---
title: "3: Compute the Standardize Precipitation Index based on spatial point."
---

<br>

## Introduction

In this tutorial, we extract the CHIRPS precipitation observations in Suriname, based on the centroids of the Principal Sampling Units (PSU) of the Suriname Survey of Living Conditions for the years 2016/17 and 2022. Based on the extracted precipitation, the tutorial shows how to compute the Standardized Precipitation Index (SPI) and merge it with the survey based on the date of interviews.


## Code
### Set Up
We start by setting up the stage for our analysis.

First, we load the necessary packages. We load only `climatic4economist` package that contains several functions meant to extract and merge spatial variables with surveys. During the tutorial we will use other packages but instead of loading all the package at the begging we will call specific function each time.

```{r packages}
#| label: packages
#| output: false

library(climatic4economist)
```

In the setup, we also want to create the paths to the various data sources and load the necessary functions for extraction. Note `..` means one step back to the folder directory, i.e. one folder back.

Note that how to set up the paths depends on your folder organization but there are overall two approaches: 

1. you can use the `R project`, by opening the project directly you don't need to set up the path to the project. Automatically the project figures out on its own where it is located in the computer and set that path as working folder. 
2. you can manually set the working folder with the function `setwd()`.

```{r paths}
#| label: paths

# path to data folder
path_to_data <- file.path("..", # <1>
                          "..", "data") # <2>

# survey 
path_to_wave_1 <- file.path(path_to_data, "survey", "surname", "wave 1",
                            "RT001_Public.dta")

path_to_wave_2 <- file.path(path_to_data, "survey", "surname", "wave 2", 
                            "2022 RT001_Housing_plus.dta")

# administrative division
path_to_adm_div <- file.path(path_to_data, "adm_div", "GAUL")

# weather variables
path_to_pre_monthly <- file.path(path_to_data, "weather", "CHIRPS", "monthly",
                                 "chirps-v2.0.monthly.nc")
# to result folder
path_to_result <- file.path(path_to_data, "result")
```
1. concatenate the string to make a path
2. `..` means one folder back

<br>

### Read the data
#### Survey
We begin by reading the surveys, which in this case consist of two waves with potentially different locations. As a result, we need to load both waves. The waves are stored as `dta` files, so we use the `haven::read_dta()` function to read them.

We only need the hhid, the survey coordinates, and the interview dates. We use `dplyr::select()` to choose these variables. This passage is optional and we bring with us all the variables, but we won't use them. Note that the first wave does not include the interview date.

We combine the two waves using `dplyr::bind_rows()`.

We can use the `head()` function to preview the data and see how it looks.

```{r read_surveys}
#| label: read_surveys

wave_1 <- haven::read_dta(path_to_wave_1) |>
    dplyr::select(hhid, lat_cen, long_cen) |> 
    dplyr::mutate(wave = 1)

wave_2 <- haven::read_dta(path_to_wave_2) |>
    dplyr::select(hhid, end_date_n, lat_cen, long_cen) |>
    dplyr::mutate(wave = 2)

survey <- dplyr::bind_rows(wave_1, wave_2)

head(survey)
```


#### Aministrative Divisions
We read the spatial file containing the national borders of Suriname, we use `read_GAUL()` to load it. By printing the spatial data, we can obtain key information, such as the dimensions (number of rows and variables), the geometry (which indicates the type of spatial object), and the coordinate reference system (CRS), which links the coordinates to precise locations on the Earth's surface. The CRS is particularly important when working with different spatial datasets, as mismatched CRSs can prevent the datasets from aligning correctly.

```{r read_adm_div}
#| label: read_adm_div

adm_div <- read_GAUL(path_to_adm_div, iso = "SUR", lvl = 2)
adm_div
```

#### Weather
Finally, we load the precipitation data. Climatic data typically comes in the form of raster data. A raster represents a two-dimensional image as a rectangular matrix or grid of pixels. These are spatial rasters because they are georeferenced, meaning each pixel (or "cell" in GIS terms) represents a square region of geographic space. The value of each cell reflects a measurable property (either qualitative or quantitative) of that region. In this case, the values are monthly precipitation that fell in that region. We use the function `terra::rast()` to load the raster data.

This particular raster has global coverage, so we crop it to focus on the country area to reduce its size. Although this step is not strictly necessary, it helps decrease the memory load and makes visualizations more manageable. We use the function `crop_with_buffer()` for this purpose.

When we print the raster, we obtain several key details. The dimension tells us how many cells the raster consists of and the number of layers, each layer corresponds to a particular months for which the observations were made. We also get the spatial resolution, which defines the size of each square region in geographic space, and the coordinate reference system (CRS). Given the importance of the CRS, we extract it using `terra::crs()` and save it for later use.

We also rename the raster layers to reflect the corresponding dates for each layer, as this is useful if we want to track the dates. We use `terra::time()` to extract the dates.

::: {.callout-note}
Note that rasters can store time information in different ways, so it may not always be possible to retrieve dates in this manner. A common alternative is for dates to be embedded in the layer names, in which case we wouldn’t need to rename the layers.
:::

```{r read_pre_monthly}
#| label: read_pre_monthly

weather_monthly <- terra::rast(path_to_pre_monthly) |>
    crop_with_buffer(adm_div)
weather_monthly

names(weather_monthly) <- terra::time(weather_monthly)
weather_monthly
```

<br>

### Georeference the survey

As we've mentioned, the weather data is georeferenced, so we need to ensure the same for the survey data. Since many households share the same coordinates, they are linked to the same weather events. To reduce computation time, we extract data only for the unique coordinates, rather than for each household. Moreover, we must ensure that we can later associate the correct weather data with the right household, we do this by creating an merging variable called `ID`.

This is handled by the `prepare_coord()` function, which requires the coordinates' variable names as input.

We can print the result to check the transformation. The new column, `ID`, is created by `prepare_coord()` and identifies each unique coordinate. This is used to merge the weather data with the household data.

```{r prepare_coord}
#| label: prepare_coord

srvy_coord <- prepare_coord(survey, lat_var = lat_cen, lon_var = long_cen)
srvy_coord
```

Once we have the unique coordinates, we are ready to transform them into spatial points using the `georef_coord()` function. When performing this transformation, it's crucial to set the correct CRS, which must match that of the weather data. The CRS is provided as an argument of the function, using the previously saved CRS from the weather data. Also the `georef_coord()` function requires the coordinates' variable names as input.

```{r georef_coord}
#| label: georef_coord

srvy_geo <- georef_coord(srvy_coord,
                          geom = c("long_cen", "lat_cen"),
                          crs = "EPSG:4326")
srvy_geo
```

Note how there are `r nrow(srvy_geo)` rows. These are the unique locations from the survey.

<br>

### Plot

A good practice when working with spatial data is to plot it. This is the best way to verify that everything is working as expected.

First, we plot the survey coordinates to ensure they are correctly located within the country and to examine their spatial distribution.

```{r plot_survey_geo}
#| label: plot_survey_geo

terra::plot(adm_div, col = "grey", main = "Suriname and PSU centroids")
terra::points(srvy_geo, col = "gold", alpha = 0.5, cex = 0.5)

```

We confirm that the survey locations are within the country borders, which is great! We also observe that the spatial distribution of survey coordinates is neither random nor uniform; most are concentrated near the capital and along the coast.

Next, we plot a layer of the precipitation data to see how it overlaps with the spatial coordinates.

```{r plot_precipitation}
#| label: plot_precipitation

terra::plot(weather_monthly, "2024-10-01", col = terra::map.pal("water"),
            main = "Monthly precipitation at 2024-10 and survey location")
terra::lines(adm_div, col = "white", lwd = 2)
terra::points(srvy_geo, col = "red", alpha = 0.5, cex = 0.5)
```

Once again, the survey coordinates align with the precipitation data, which is great! We can also observe the high spatial resolution of the CHIRPS dataset. However, despite this high resolution, some survey coordinates still fall within the same cell.

<br>

### Extract

Next, we extract the weather data based on the survey coordinates using the `extract_by_coord()` function. This function requires the raster with the weather data and the georeferenced coordinates as inputs.

Looking at the result, we see first the `ID` column, that identifies the unique survey coordinates. The second and third column are the coordinates of the cells. The other columns contain the weather observations over time specific to each coordinate.

```{r extract_precipitation}
#| label: extract_precipitation

pre_coord <- extract_by_coord(raster = weather_monthly, 
                              coord = srvy_geo)
pre_coord

```

Again we have a row for each unique location from the survey. However, if we want to know how many different cells there are we can look unique cell coordinates.

```{r cell_coordinate}
#| label: cell_coordinate

unique_cell <- pre_coord |>
  dplyr::distinct(x_cell, y_cell)
nrow(unique_cell)
```

We see that now the number of rows is `r nrow(unique_cell)`, this is the actual different weather observation that we can merge with the survey.

<br>

### Compute the SPI
We now compute the SPI with the function `compute_spi()`. This function requires the precipitation time series for each location and the time scale at which the SPI is computed.

To compute the SPI, it is recommended to use at least 30 years of observation to ensure a good estimation of the parameters. More years can strength the estimation but the results can be affected by climate change: if there have been a change in the climate parameters, old observations might be not indicative of the current situation affecting the estimation. There are no clear rule on this, so we leave add the possibility to select the time range of observation with the function `select_by_dates()`. The function requires both or just one between the starting date, `from`, and the end date `to`. If both are provide the the function select between the two dates, if only `from` is provided the function selects all date after, and if only `to` is provided the function selects all date before.

Looking at the result, we see first is the `ID` column, that we will use to merge back with the survey. The other columns contain the SPI observations over time specific to each coordinate.

```{r compute_spi3}
#| label: compute_spi3
#| warning: false

# coord  <- select_by_dates(coord, from = "1991-01-01", to = "2023-01-01") 

spi3 <- compute_spi(pre_coord, time_scale = 3)
spi3
```

If we want to calculate the SPI with time scale equal to one, we just need to change the `time_scale` argument.

```{r compute_spi1}
#| label: compute_spi1
#| warning: false

spi1 <- compute_spi(pre_coord, time_scale = 1)
spi1
```

<br>


### Merge with survey
Now, we combine the extracted weather data with the survey data using `ID` as the key matching variable.

```{r merge_spi}
#| label: merge_spi

spi3_survey <- merge_with_survey(srvy_coord, spi3)

spi3_survey
```

We are back at `r nrow(spi3_survey)`, which matches the original survey.

<br>

### Select based on the interview
Now that we have merged the SPI values with the survey, we can select just the relevant observations.

If we want to select just a subsets of observations we can use the `select_by_dates()` function. If we want to select based on the date of interview of the survey, we can use `select_by_interview()`. This last function requires the variable that contains the dates of interview and the interval to select based on the dates. The interval must be express in number of months or in number years. The `wide` argument specifies how the output should be reported, in wide with each time observation as separate columns, or long, with all observation in one column.

>Note that current version of the `select_by_interview()` functions drops the observations with missing date of interview.

What is relevant depends on the particular application, but we can agree that we don't want to assign weather observations that happened after the interviews, as these cannot influence the answers.

In this tutorial we select the 12 months before the interviews using the function `select_by_interview()`. The argument `interview` select the variable containing the date of interviews, and the argument `interval` defines how back in time the function needs to select the observations.

If there are missing observations for the date of interviews, the function warns us that these observations are dropped.

```{r select_by_interview}
#| label: select_by_interview

spi3_hh <- select_by_interview(spi3_survey,
                               interview = end_date_n,
                               interval = "1 year",
                               wide = TRUE)
```

<br>

### Save

The final step of the code is to save the result. In this case, we save it as a `dta` file using the `haven::write_dta()` function.


```{r write_data}
#| label: write_data
#| eval: false

haven::write_dta(spi1_survey, file.path(path_to_result, "spi_1.dta"))

haven::write_dta(spi3_hh, file.path(path_to_result, "spi_3.dta"))
```

<br><br>

## Take home messages

* When working with multiple spatial data:
  
  1. remember to control the Coordinate Reference System of all dataset
  2. plot the data to check everything is going well
  
* based on the typology of data we use different function to read them
    * for `dta` use `haven::read_dta() or` and `haven::_write_dta()`
    * for spatial vectors `read_GAUL()` for administrative divisions in specific country and level, otherwise `terra::vect()`
    * for spatial raster use `terra::rast()`

* Extraction
    * since many household share the same locations, we take advantage of this by extracting the weather data only at the unique locations, we achieve this with the function `prepare_coord()`.
    * same of these unique locations may fall within the same value cells, so the actual information might be even lower.
    
<br><br>
  
## Appendix
### Want to know about the data?

#### Precipitation

Monthly and daily precipitation from Climate Hazards Group InfraRed Precipitation with Station data (CHIRPS)[^1] is a 35+ year quasi-global rainfall data set. Spanning 50°S-50°N (and all longitudes) and ranging from 1981 to near-present, CHIRPS incorporates in-house climatology, CHPclim, 0.05° resolution satellite imagery, and in-situ station data to create gridded rainfall time series for trend analysis and seasonal drought monitoring.

[^1]: Funk, C.C., Peterson, P.J., Landsfeld, M.F., Pedreros, D.H., Verdin, J.P., Rowland, J.D., Romero, B.E., Husak, G.J., Michaelsen, J.C., and Verdin, A.P., 2014, A quasi-global precipitation time series for drought monitoring: U.S. Geological Survey Data Series 832, 4 p. http://pubs.usgs.gov/ds/832/

Data can be downloaded from [here](https://data.chc.ucsb.edu/products/CHIRPS-2.0/global_monthly/netcdf/) while extra information are available [here](https://www.chc.ucsb.edu/).

| feature             | value                 |
|:--------------------|:----------------------|
| spatial resolution  | 0.05 x 0.05 (\~ 5 km) |
| temporal resolution | monthly or daily      |
| temporal frame      | 1981 - near present   |
| unit of measure     | mm/month or mm/day    |

#### Surveys

Suriname Survey of Living Conditions. The 2022 Suriname Survey of Living Conditions is a joint survey made by The Inter-American Development Bank (IDB) and the World Bank. The 2022 Suriname Survey of Living Conditions - administered to a nationally representative sample, which included 7,713 individuals from 2,540 households - was developed to support poverty analysis as well as policy planning and is a helpful tool for policy makers to facilitate fact-based decision making. The survey’s design and execution were financed by the IDB, while the World Bank and IDB are joining forces to analyze data and produce initial findings.

The Suriname Survey of Living Conditions (SSLC) 2016/17 is an effort of the Inter-American Development Bank (IDB) with the support of the EnergieBedrijvan Suriname’s (state-owned electrical company of Suriname) and the Central Bank of Suriname. It visited about 2,000 households from October 2016 through September 2017 and collected data on the most important dimensions of welfare, which will support evidence-based policy making in areas such as education, health, housing, employment and poverty alleviation. The survey also gathered information on the consumption patterns, income and expenditures of the Surinamese households, intended to update the Consumption Price Index basket and inform the System of National Accounts.

For extra info look [here](https://openknowledge.worldbank.org/entities/publication/2d0e6975-2f85-4d12-83fa-4f75c617cf89) and [here](https://webapps.ilo.org/surveyLib/index.php/catalog/7499).

#### Adminitrative boundaries

The Global Administrative Unit Layers (GAUL) 2024 is a vector dataset compiling the most recent available information on administrative boundaries from multiple sources, produced by FAO from 2022 to 2024 in the framework of the Hand-in-Hand Initiative and the Geospatial Data Platform activities.

The GAUL 2024 aims at maintaining global layers with a unified coding system at country, first (e.g. departments), and second (e.g. districts) administrative levels.
The data, sourced and processed from the United Nations Second Administrative Level Boundaries (UN-SALB) programme and from other relevant data sources, was complemented by the UN-FAO-CSI AgroInformatics Geospatial Analysis team with data from official geospatial data producers. Country boundaries were processed against UN official recognized borders (UN-map 2018), and the administrative subdivisions were checked for geometry and topology, then corrected and validated.
The administrative boundaries dataset at level 1 and 2 (Sub-national level) is part of the Global Administrative Unit Layers (GAUL) dataset series which includes information on administrative units for all the countries in the world, providing a contribution to the standardization of the spatial dataset representing administrative units.
The administrative boundaries at the level 1 dataset distinguishes States, Provinces, Departments and equivalent. The administrative boundaries at the level 2 dataset distinguishes Districts and equivalent.

Suggested citation:

* FAO. 2024. Global Administrative Unit Layers (GAUL). [Accessed on [DD Month YYYY]]. https://data.apps.fao.org/?lang=en. Licence: CC-BY-4.0 

It is possible to find additional information: 

* [here](https://data.apps.fao.org/catalog/dataset/global-administrative-unit-layers-gaul-2024) 

The data can be freely download from 

* [here](https://data.apps.fao.org/catalog/dataset/34f97afc-6218-459a-971d-5af1162d318a).

