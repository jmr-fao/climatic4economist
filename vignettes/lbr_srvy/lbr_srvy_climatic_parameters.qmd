---
title: "Extract Long Term Climate Conditions"
author: "JMR"
toc: true
toc-expand: 1
toc-depth: 2
format:
  html:
    self-contained: true
    code-tools: true
    toc-location: right-body
  docx: 
    toc-location: body
editor: source
editor_options:
  chunk_output_type: console
vignette: >
  %\VignetteIndexEntry{Vignette's Title}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{quarto::html}
---

## Intro
This tutorial will explore how to extract weather observations based on survey coordinates and compute long term climatic parameter to summarize the climatic condition of the coordinates. We will compute the long term mean and the long term coefficient of variation for precipitation and temperature.

The weather extreme events are calculated based on the locations of the LSMS survey. We use five surveys from Ethiopia, Malawi, Niger, Nigeria, and Tanzania. 

The reference period to calculate the long term climatic parameters is 30 years before the survey.

We will use total precipitation and 2 meters above ground temperature from ERA5 Land.

## Overview of Steps
In this guide, we will go through the following steps:

1. Load the data
2. Prepare the survey coordinate
3. Aggregate the weather observation from monthly to annual frequency
4. Extract the new annual weather observation based on the coordinates
5. Compute the long term parameters
6. Save the result

## Is this guide for me?

This guide provides a step-by-step approach to extract raster data based on survey locations. The target audience includes economists who may have experience with statistical software (e.g. STATA) but are less familiar with spatial data processing in R.

The document is not meant to be a course on R or on how the functions work. It is just a practice example on how to extract raster data based on coordinate location. This is done by using specific functions that wrap up as many steps as possible to ensure it is easier for the user to follow.

## What do I need before starting?

The following R packages are necessary: `terra`, `tidyverse`, `haven`, `data.table`. To install the above package you can use `install.packages("name_of_package")`, don't forget the `"`. We also need the  package `climate4economist`, which can be installed only locally.

If you are not familiar with R check the [appendix] for understanding some coding style used in this tutorial.

## Code
### Set Up
```{r paths}
#| label: paths

path_to_weather <- file.path(#"..",
                             "data", "weather", "ERA5_Land")
path_to_pre <- file.path(path_to_weather, "monthly_pre",
                         "era5_monthly_means_50_21_pre.nc")
path_to_tmp <- file.path(path_to_weather, "monthly_tmp",
                         "era5_monthly_means_50_21_tmp.nc")

path_to_survey <- file.path(#"..",
                            "data", "survey", "LSMS_labor_survey",
                            "labour_forYR_coordinates_new.dta")

path_to_climate_par <- file.path("data", "result", "lbr_srv_climate_par.dta")
```

```{r package}
#| label: package

library(climatic4economist)
```

### Read
```{r read_weather}
#| label: read_weather

pre <- terra::rast(path_to_pre)
names(pre) <- terra::time(pre)

tmp <- terra::rast(path_to_tmp)
names(tmp) <- terra::time(tmp)
```

```{r read_survey}
#| label: read_survey

surveys <- haven::read_dta(path_to_survey) |>
  dplyr::filter(survey != "Uganda16") |> # 100849
  dplyr::filter(!is.na(lon_mod) & !is.na(lat_mod)) |>
  dplyr::select(survey, hhid, id_code, lat_mod, lon_mod) |>
  dplyr::distinct(survey, hhid, .keep_all = TRUE) |>
  dplyr::group_by(survey) |>
  dplyr::group_split() |>
  setNames(c("Ethiopia19", "Malawi17", "Niger14", "Nigeria19", "Tanzania13"))
```

### Prepare the survey coordinates
```{r geo_ref}
#| label: geo_ref

surveys_id <- lapply(surveys,
                     prepare_coord,
                     lon_var = lon_mod,
                     lat_var = lat_mod) 

survey_geo <- lapply(surveys_id,
                     georef_coord,
                     geom = c("lon_mod", "lat_mod"),
                     crs = "EPSG:4326") 
```

### Crop
```{r crop}
#| label: crop

pre_cntry <- sapply(survey_geo,
                    terra::crop,
                    x = pre,
                    snap = "out",
                    simplify = FALSE) 

tmp_cntry <- sapply(survey_geo,
                    terra::crop,
                    x = tmp,
                    snap = "out",
                    simplify = FALSE)
```

### Time aggregation
```{r aggregate}
#| label: aggregate

pre_yr <- purrr::map2(pre_cntry,
                      names(pre_cntry),
                      aggregate_frequency, 
                      target_freq = "%Y",
                      agg_fn = "sum")

tmp_yr <- purrr::map2(tmp_cntry,
                      names(tmp_cntry),
                      aggregate_frequency, 
                      target_freq = "%Y",
                      agg_fn = "mean")
```

### Transformation
```{r transformation}
#| label: transformation

# From meter to millimeters
pre_yr_mm <- purrr::map(pre_yr, ~ .x*1000)

# From Kelvin to Celsius
tmp_yr_c <- purrr::map(tmp_yr, ~ .x - 273.15)
```

### Extract
```{r extract}
#| label: extract

pre_coord <- pre_yr_mm |>
  purrr::map(terra::focal,
             w = 3, 
             fun = "mean", 
             na.policy = "only") |>
  purrr::map2(survey_geo,
              extract_by_coord)

tmp_coord <- tmp_yr_c |>
  purrr::map(terra::focal,
             w = 3, 
             fun = "mean", 
             na.policy = "only") |>
  purrr::map2(survey_geo,
              extract_by_coord)
```

### Calculate climatic parameters
```{r select_by_dates}
#| label: select_by_dates

pre_coord_30yrs <- purrr::pmap(
  list(pre_coord,
       list("1989", "1988", "1986", "1989", "1984"),
       list("2019", "2018", "2016", "2019", "2014")),
  select_by_dates)

tmp_coord_30yrs <- purrr::pmap(
  list(tmp_coord,
       list("1989", "1988", "1986", "1989", "1984"),
       list("2019", "2018", "2016", "2019", "2014")),
  select_by_dates)
```


```{r cal_parameter}
#| label: cal_parameter

parameter <- c(std = sd, avg = mean, coef_var = cv)

pre_climate_par <- lapply(pre_coord_30yrs,
                          calc_par,
                          agg_fns = parameter,
                          prefix = "pre")

tmp_climate_par <- lapply(tmp_coord_30yrs,
                          calc_par,
                          agg_fns = parameter,
                          prefix = "tmp")
```

### Merge with Survey
```{r merge_with_survey}
#| label: merge_with_survey

pre_climate_par_hh <- purrr::map2(surveys_id,
                                  pre_climate_par,
                                  merge_with_survey)

tmp_climate_par_hh <- purrr::map2(surveys_id,
                                  tmp_climate_par,
                                  merge_with_survey)
```

### Write
```{r write}
#| label: write

purrr::map2(pre_climate_par_hh,
            tmp_climate_par_hh,
            dplyr::full_join,
            by = c("ID", "survey", "hhid", "id_code", "lat_mod", "lon_mod")) |>
  dplyr::bind_rows() |>
  haven::write_dta(path_to_climate_par)
```

## Appendix
### New to R? Read this first!
#### The pipe command

The pipe command `|>`. It lets you pass the result of one expression as the first argument to the next, creating a fluid chain of functions.

#### The package namespaces

The package namespaces `package_name::function_name()`. As the name suggests, namespaces provide "spaces" for "names". They provide a context for looking up the value of an object associated with a name. When we write `terra::vect()` we are asking R to look for the function `vect()` in the `terra` package.

It's a fairly advanced topic, and by-and-large, not that important! When you first start using namespaces, it'll seem like a lot of work for little gain. However, having a high quality namespace helps encapsulate your package and makes it self-contained. This ensures that other packages won't interfere with your code, that your code won't interfere with other packages, and that your package works regardless of the environment in which it's run.

You can avoid using every time the name space by just loading the necessary packages at the beginning of the code (in the set up section for example). This is the most known and common approach. To do so just add `library(name_of_package)`, for example `library(terra)`. Then we can just call the function without the name space, like this `vect()`.

#### The assign operator

The assign operator `<-`. This is a peculiarity of R and it is used to assign values to variables. Note that the operators `<-` and `=` can be used, almost interchangeably.


### Want to know about the data?
#### Weather
Weather observation are obtained from ERA5-Land reanalysis dataset. H-TESSEL is the land surface model that is the basis of ERA5-Land. The data is a post-processed monthly-mean average of the original ERA5-Land dataset.

It is possible to find additional information [here](https://cds.climate.copernicus.eu/cdsapp#!/dataset/reanalysis-era5-land-monthly-means?tab=overview) and the related manual [here](https://confluence.ecmwf.int/display/CKB/ERA5-Land). 
The data can be freely download from [here](https://cds.climate.copernicus.eu/cdsapp#!/dataset/reanalysis-era5-land-monthly-means?tab=overview).


| Parameter           | Value                   |
|:--------------------|:-----------------------:|
| spatial resolution  | 0.1° x 0.1° lon lat     |
| temporal resolution | month                   |
| time frame          | Jan. 1950 - Dec. 2022   |
| unit of measure     | meter or Kelvin         |


##### Total precipitation
Accumulated liquid and frozen water, including rain and snow, that falls to the Earth's surface. It is the sum of large-scale precipitation and convective precipitation. Precipitation variables do not include fog, dew or the precipitation that evaporates in the atmosphere before it lands at the surface of the Earth.

##### 2 metre above ground temperature
Temperature of air at 2m above the surface of land, sea or in-land waters. 2m temperature is calculated by interpolating between the lowest model level and the Earth's surface, taking account of the atmospheric conditions.

#### Survey
The Living Standards Measurement Study - Integrated Surveys on Agriculture (LSMS-ISA) is a unique system of longitudinal surveys designed to improve the understanding of household and individual welfare, livelihoods and smallholder agriculture in Africa. The LSMS team works with national statistics offices to design and implement household surveys with a strong focus on agriculture.

Additional information can be find [here](https://www.worldbank.org/en/programs/lsms). The data can be download from [here](https://microdata.worldbank.org/index.php/home).

The following survey are used in this tutorial.

| Survey    | Year |
|:----------|-----:|
| Ethiopia  | 2019 |
| Malawi    | 2017 |
| Niger     | 2014 |
| Nigeria   | 2019 |
| Tanzania  | 2013 |

