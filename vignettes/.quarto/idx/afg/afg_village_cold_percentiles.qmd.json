{"title":"Cold percentiles in the Villages of Afghanistan","markdown":{"yaml":{"title":"Cold percentiles in the Villages of Afghanistan","author":"JMR","toc":true,"toc-expand":1,"toc-depth":2,"format":{"html":{"self-contained":true,"code-tools":true,"toc-location":"right-body"},"docx":{"toc-location":"body"}},"editor":"source","editor_options":{"chunk_output_type":"console"},"vignette":"%\\VignetteIndexEntry{Vignette's Title} %\\VignetteEncoding{UTF-8} %\\VignetteEngine{quarto::html}\n"},"headingText":"Code","containsRefs":false,"markdown":"\n\n\n### Set Up\n\nIn the setup, we create the paths to the various data sources and load the necessary functions for extraction. Note `..` means one step back to the folder directory, i.e. one folder back.\n\n```{r set_up}\n#| label: set_up\n\npath_to_data <- file.path(\"..\",\n                          \"..\", \"data\")\n\npath_to_tmp_min <- file.path(path_to_data, \"weather\", \"ERA5_Land\", \"AFG\", \"daily\", \n                             \"2m_temperature\")\n\npath_to_village <- file.path(path_to_data, \"survey\", \"AFG\",\n                             \"Village coordinates_CoF(Village level coordinates).csv\")\n\npath_to_adm_div <- file.path(path_to_data, \"adm_div\", \"UN_borders\", \"UN-AFG-ADM2.gpkg\")\n```\n\n\n```{r package}\n#| label: package\n\nlibrary(climatic4economist)\n```\n\n### Load the data\nLet's start by loading the data into R. We load the weather observation with the function `terra::rast()`. As the raw data is made of two different files, we first load each one with the `lapply()` function and than we aggregate them with the `terra::rast()` function. Note that we changed the order of the list item to have them ordered by date. This has no computational implication for this tutorial but it is nicer. \n\n>We set the names of the layer as the date of observation. This is very important for later.\n\n```{r read_weather}\n#| label: read_weather\n\ntmp_min_k <- list.files(path_to_tmp_min, full.names = TRUE) |>\n  lapply(terra::rast)\ntmp_min_k\n\ntmp_min_k <- terra::rast(list(tmp_min_k[[2]], tmp_min_k[[1]]))\n\nnames(tmp_min_k) <- terra::time(tmp_min_k)\ntmp_min_k\n```\n\nNow we load the villages. We rename the variable for easier use.\n\n>It is very important to check if the village and the raster data share the same coordinate reference system!\n\nUsually, the WGS 84 CRS is the default coordinate references system for coordinates. In this case it  matches the weather coordinate references system.\n\n```{r read_villages}\n#| label: read_villages\n\nvillage <- data.table::fread(path_to_village) |> \n    dplyr::rename(lon = \"Longitude (X)\",\n                  lat = \"Latitude (Y)\")\nvillage\n```\n\nWe load the administrative divisions to check where the villages are.\n\n```{r read_adm_div}\n#| label: read_ad_div\n\nadm_div <- terra::vect(path_to_adm_div)\nadm_div\n```\n\n### Georeference the survey\n\nAs we've mentioned, the weather data is georeferenced, so we need to ensure the same for the survey data. \n\nwe must ensure that we can later associate the correct weather data with the right household, we do this by creating an merging variable called `ID`.\n\nThis is handled by the `prepare_coord()` function, which requires the coordinates' variable names as input.\n\nOnce we have the unique coordinates, we are ready to transform them into spatial points using the `georef_coord()` function. When performing this transformation, it's crucial to set the correct CRS, which must match that of the weather data. The CRS is provided as an argument of the function, using the previously saved CRS from the weather data. Also the `georef_coord()` function requires the coordinates' variable names as input.\n\n\n```{r georef_coord}\n#| label: georef_coord\n\nvillage_coord <- prepare_coord(village,\n                               lon_var = lon,\n                               lat_var = lat)\n\nvillage_geo <- georef_coord(village_coord,\n                            geom = c(\"lon\", \"lat\"),\n                            crs = \"EPSG:4326\")\nvillage_geo\n```\n\n### Plot\n\nA good practice when working with spatial data is to plot it. This is the best way to verify that everything is working as expected.\n\nFirst, we plot the administrative division and the villages to ensure they are correctly located and we examine their spatial distribution. \n\n```{r plot_survey_geo}\n#| label: plot_survey_geo\n\nterra::plot(adm_div, \n            col = \"grey80\",\n            border=\"grey60\",\n            lwd = 0.1,\n            main = \"Afganistan's District and Programme Villages\")\nterra::points(village_geo, col = \"blue\", cex = 1)\n\nvillage_geo |> \n    tidyterra::filter(ID == 47) |> \n    terra::text(\"ID\", col = \"red\")\n```\n\nWe can see that the village `ID == 47` is isolated fro the other villages, which tend to cluster in two distinct areas. I would suggest to double check the accuracy of this village.\n\n```{r oulier}\n#| label: oulier\n\nvillage_coord |> \n    dplyr::filter(ID == 47) |> \n    knitr::kable()\n```\n\n\nNext, we plot a layer of the minimum temperature data to see how it overlaps with the spatial coordinates.\n\n```{r plot_precipitation}\n#| label: plot_precipitation\n\nterra::plot(tmp_min_k, \"2022-12-31\", col = terra::map.pal(\"water\"),\n            main = \"Daily minimum temperature on 2022-12-31 and village locations\")\nterra::points(village_geo, col = \"gold\", cex = 0.8)\n```\n\nOnce again, the villages coordinates align with the temperature data, which is great!\n\n\n### Extract\n\nNext, we extract the weather data based on the village coordinates using the `extract_by_coord()` function. This function requires the raster with the weather data and the georeferenced coordinates as inputs.\n\nLooking at the result, we see first the `ID` column, that identifies the village coordinates. The second and third column are the coordinates of the cells. The other columns contain the weather observations over time specific to each coordinate.\n\n```{r extract_tmin}\n#| label: extract_tmin\n\ntmin_village_k <- extract_by_coord(raster = tmp_min_k, \n                                   coord = village_geo)\ntmin_village_k\n\n```\n\nAgain we have a row for each unique village. However, if we want to know how many different cells there are we can look unique cell coordinates.\n\n```{r cell_coordinate}\n#| label: cell_coordinate\n\nunique_cell <- tmin_village_k |>\n  dplyr::distinct(x_cell, y_cell)\nnrow(unique_cell)\n```\n\nWe see that now the number of rows is `r nrow(unique_cell)`, this is the actual different weather observation that we can merge with the villages. In other words, many villages share the same weather observation as they fall within the same pixel.\n\n\n### Prepare data\nThe original unit of measure of the temperature in Kelvin, we change it into Celsius.\n\n```{r transformation}\n#| label: transformation\n\ntmin_village_c <- tmin_village_k |>\n  dplyr::mutate(dplyr::across(.cols = dplyr::matches(\"[0-9]{4}\"),\n                              .fns = ~ .x - 273.15))\n```\n\nBefore calculating the percentile we select just the observations after 1980 with the function `select_by_dates()`. Indeed, 30 years is usually considered enough observation to evaluate climatic parameters, and weather observation before 1980 are considered less reliable.\n\n```{r prepare_coord}\n#| label: prepare_coord\n\ntmin_village_c_80 <- select_by_dates(tmin_village_c, from = \"1980-01-01\")\n```\n\n### Calculate percentiles\n>If we believe the thresholds shouldn't be the same across all the location but instead be adaptive to the local long run climatic condition we should use the relative thresholds. In this case the thresholds varies for each location, adapting to the local climatic features and making the spatial comparison among heterogeneous places more meaningful. The relative approach measures the extreme weather events in term of their rarity, which is measured by the percentile of their local and seasonal distribution.\n\nWe now calculate the percentiles with the function `calc_pct_day()`. The functions requires the weather observations with the additional variable `ID` and the desired percentiles to be computed. \n\nWe are interested in cold percentiles, therefore we calculate the extreme percentiles of the left tail.\n\nEventually, we could also have provided two additional arguments to the function. These are `l_thresh` and `u_thresh`, which removes the observations which are below the `l_thresh` or above `u_thresh`. For example, since we are looking for cold percentile we could have add `u_thresh = 0` to filter out all temperatures above zero degree Celsius and leave just the cold observations. This can be interpreted as an upper bound of the cold percentiles which will never be above the `u_thresh`.\n\n```{r percentiles}\n#| label: percentiles\n\ntmin_min_pct <- calc_pct_day(tmin_village_c_80, p = c(0.01, 0.05, 0.1), yearly = TRUE)\ntmin_min_pct\n```\n\nThe first two columns of the result identify the unique location and the month. The month is important as we compute the  statistic for each month to account for climatic seasonality.\n\n>Note that even if we compute the statitics for each month the unit of measure refer to the daily minimum temperature.\n\n\n### Merge with survey\n\nNow, we combine the extracted weather data with the village data using `merge_with_survey()`, which under the hood uses the variable `ID` as the key matching variable.\n\n```{r merge_tmin_pct}\n#| label: merge_tmin_pct\n\ntmin_pct_village <- merge_with_survey(village_coord, tmin_min_pct)\ntmin_pct_village\n```\n\n### Write\nAs a final step we save the result for future calculation. \n\nWe save it as an `rds` object, which is the native R format. We do it as the next calculation will be in R and this format helps for the compression and reading of the data. However, if the data will be use in other software it is still possible to save in other format.  For example, `haven::write_dta()` for `dta` format or `data.table::fwrite()` for `csv`.\n\n```{r write}\n#| label: write\n\ndplyr::full_join(village_coord, \n                 tmin_village_c, by = \"ID\") |>\n  dplyr::as_tibble() |>\n  saveRDS(file = file.path(path_to_data, \"weather\", \"ERA5_Land\", \"AFG\", \n                           \"daily\",  \"day_50_25_2m_tmp_min_village.rds\"))\n\n\nsaveRDS(tmin_pct_village,\n        file = file.path(path_to_data, \"weather\", \"ERA5_Land\", \"AFG\", \n                         \"percentile\",  \"pct_80_25_2m_tmp_min_village.rds\"))\n```\n\n","srcMarkdownNoYaml":"\n\n\n## Code\n### Set Up\n\nIn the setup, we create the paths to the various data sources and load the necessary functions for extraction. Note `..` means one step back to the folder directory, i.e. one folder back.\n\n```{r set_up}\n#| label: set_up\n\npath_to_data <- file.path(\"..\",\n                          \"..\", \"data\")\n\npath_to_tmp_min <- file.path(path_to_data, \"weather\", \"ERA5_Land\", \"AFG\", \"daily\", \n                             \"2m_temperature\")\n\npath_to_village <- file.path(path_to_data, \"survey\", \"AFG\",\n                             \"Village coordinates_CoF(Village level coordinates).csv\")\n\npath_to_adm_div <- file.path(path_to_data, \"adm_div\", \"UN_borders\", \"UN-AFG-ADM2.gpkg\")\n```\n\n\n```{r package}\n#| label: package\n\nlibrary(climatic4economist)\n```\n\n### Load the data\nLet's start by loading the data into R. We load the weather observation with the function `terra::rast()`. As the raw data is made of two different files, we first load each one with the `lapply()` function and than we aggregate them with the `terra::rast()` function. Note that we changed the order of the list item to have them ordered by date. This has no computational implication for this tutorial but it is nicer. \n\n>We set the names of the layer as the date of observation. This is very important for later.\n\n```{r read_weather}\n#| label: read_weather\n\ntmp_min_k <- list.files(path_to_tmp_min, full.names = TRUE) |>\n  lapply(terra::rast)\ntmp_min_k\n\ntmp_min_k <- terra::rast(list(tmp_min_k[[2]], tmp_min_k[[1]]))\n\nnames(tmp_min_k) <- terra::time(tmp_min_k)\ntmp_min_k\n```\n\nNow we load the villages. We rename the variable for easier use.\n\n>It is very important to check if the village and the raster data share the same coordinate reference system!\n\nUsually, the WGS 84 CRS is the default coordinate references system for coordinates. In this case it  matches the weather coordinate references system.\n\n```{r read_villages}\n#| label: read_villages\n\nvillage <- data.table::fread(path_to_village) |> \n    dplyr::rename(lon = \"Longitude (X)\",\n                  lat = \"Latitude (Y)\")\nvillage\n```\n\nWe load the administrative divisions to check where the villages are.\n\n```{r read_adm_div}\n#| label: read_ad_div\n\nadm_div <- terra::vect(path_to_adm_div)\nadm_div\n```\n\n### Georeference the survey\n\nAs we've mentioned, the weather data is georeferenced, so we need to ensure the same for the survey data. \n\nwe must ensure that we can later associate the correct weather data with the right household, we do this by creating an merging variable called `ID`.\n\nThis is handled by the `prepare_coord()` function, which requires the coordinates' variable names as input.\n\nOnce we have the unique coordinates, we are ready to transform them into spatial points using the `georef_coord()` function. When performing this transformation, it's crucial to set the correct CRS, which must match that of the weather data. The CRS is provided as an argument of the function, using the previously saved CRS from the weather data. Also the `georef_coord()` function requires the coordinates' variable names as input.\n\n\n```{r georef_coord}\n#| label: georef_coord\n\nvillage_coord <- prepare_coord(village,\n                               lon_var = lon,\n                               lat_var = lat)\n\nvillage_geo <- georef_coord(village_coord,\n                            geom = c(\"lon\", \"lat\"),\n                            crs = \"EPSG:4326\")\nvillage_geo\n```\n\n### Plot\n\nA good practice when working with spatial data is to plot it. This is the best way to verify that everything is working as expected.\n\nFirst, we plot the administrative division and the villages to ensure they are correctly located and we examine their spatial distribution. \n\n```{r plot_survey_geo}\n#| label: plot_survey_geo\n\nterra::plot(adm_div, \n            col = \"grey80\",\n            border=\"grey60\",\n            lwd = 0.1,\n            main = \"Afganistan's District and Programme Villages\")\nterra::points(village_geo, col = \"blue\", cex = 1)\n\nvillage_geo |> \n    tidyterra::filter(ID == 47) |> \n    terra::text(\"ID\", col = \"red\")\n```\n\nWe can see that the village `ID == 47` is isolated fro the other villages, which tend to cluster in two distinct areas. I would suggest to double check the accuracy of this village.\n\n```{r oulier}\n#| label: oulier\n\nvillage_coord |> \n    dplyr::filter(ID == 47) |> \n    knitr::kable()\n```\n\n\nNext, we plot a layer of the minimum temperature data to see how it overlaps with the spatial coordinates.\n\n```{r plot_precipitation}\n#| label: plot_precipitation\n\nterra::plot(tmp_min_k, \"2022-12-31\", col = terra::map.pal(\"water\"),\n            main = \"Daily minimum temperature on 2022-12-31 and village locations\")\nterra::points(village_geo, col = \"gold\", cex = 0.8)\n```\n\nOnce again, the villages coordinates align with the temperature data, which is great!\n\n\n### Extract\n\nNext, we extract the weather data based on the village coordinates using the `extract_by_coord()` function. This function requires the raster with the weather data and the georeferenced coordinates as inputs.\n\nLooking at the result, we see first the `ID` column, that identifies the village coordinates. The second and third column are the coordinates of the cells. The other columns contain the weather observations over time specific to each coordinate.\n\n```{r extract_tmin}\n#| label: extract_tmin\n\ntmin_village_k <- extract_by_coord(raster = tmp_min_k, \n                                   coord = village_geo)\ntmin_village_k\n\n```\n\nAgain we have a row for each unique village. However, if we want to know how many different cells there are we can look unique cell coordinates.\n\n```{r cell_coordinate}\n#| label: cell_coordinate\n\nunique_cell <- tmin_village_k |>\n  dplyr::distinct(x_cell, y_cell)\nnrow(unique_cell)\n```\n\nWe see that now the number of rows is `r nrow(unique_cell)`, this is the actual different weather observation that we can merge with the villages. In other words, many villages share the same weather observation as they fall within the same pixel.\n\n\n### Prepare data\nThe original unit of measure of the temperature in Kelvin, we change it into Celsius.\n\n```{r transformation}\n#| label: transformation\n\ntmin_village_c <- tmin_village_k |>\n  dplyr::mutate(dplyr::across(.cols = dplyr::matches(\"[0-9]{4}\"),\n                              .fns = ~ .x - 273.15))\n```\n\nBefore calculating the percentile we select just the observations after 1980 with the function `select_by_dates()`. Indeed, 30 years is usually considered enough observation to evaluate climatic parameters, and weather observation before 1980 are considered less reliable.\n\n```{r prepare_coord}\n#| label: prepare_coord\n\ntmin_village_c_80 <- select_by_dates(tmin_village_c, from = \"1980-01-01\")\n```\n\n### Calculate percentiles\n>If we believe the thresholds shouldn't be the same across all the location but instead be adaptive to the local long run climatic condition we should use the relative thresholds. In this case the thresholds varies for each location, adapting to the local climatic features and making the spatial comparison among heterogeneous places more meaningful. The relative approach measures the extreme weather events in term of their rarity, which is measured by the percentile of their local and seasonal distribution.\n\nWe now calculate the percentiles with the function `calc_pct_day()`. The functions requires the weather observations with the additional variable `ID` and the desired percentiles to be computed. \n\nWe are interested in cold percentiles, therefore we calculate the extreme percentiles of the left tail.\n\nEventually, we could also have provided two additional arguments to the function. These are `l_thresh` and `u_thresh`, which removes the observations which are below the `l_thresh` or above `u_thresh`. For example, since we are looking for cold percentile we could have add `u_thresh = 0` to filter out all temperatures above zero degree Celsius and leave just the cold observations. This can be interpreted as an upper bound of the cold percentiles which will never be above the `u_thresh`.\n\n```{r percentiles}\n#| label: percentiles\n\ntmin_min_pct <- calc_pct_day(tmin_village_c_80, p = c(0.01, 0.05, 0.1), yearly = TRUE)\ntmin_min_pct\n```\n\nThe first two columns of the result identify the unique location and the month. The month is important as we compute the  statistic for each month to account for climatic seasonality.\n\n>Note that even if we compute the statitics for each month the unit of measure refer to the daily minimum temperature.\n\n\n### Merge with survey\n\nNow, we combine the extracted weather data with the village data using `merge_with_survey()`, which under the hood uses the variable `ID` as the key matching variable.\n\n```{r merge_tmin_pct}\n#| label: merge_tmin_pct\n\ntmin_pct_village <- merge_with_survey(village_coord, tmin_min_pct)\ntmin_pct_village\n```\n\n### Write\nAs a final step we save the result for future calculation. \n\nWe save it as an `rds` object, which is the native R format. We do it as the next calculation will be in R and this format helps for the compression and reading of the data. However, if the data will be use in other software it is still possible to save in other format.  For example, `haven::write_dta()` for `dta` format or `data.table::fwrite()` for `csv`.\n\n```{r write}\n#| label: write\n\ndplyr::full_join(village_coord, \n                 tmin_village_c, by = \"ID\") |>\n  dplyr::as_tibble() |>\n  saveRDS(file = file.path(path_to_data, \"weather\", \"ERA5_Land\", \"AFG\", \n                           \"daily\",  \"day_50_25_2m_tmp_min_village.rds\"))\n\n\nsaveRDS(tmin_pct_village,\n        file = file.path(path_to_data, \"weather\", \"ERA5_Land\", \"AFG\", \n                         \"percentile\",  \"pct_80_25_2m_tmp_min_village.rds\"))\n```\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":2,"self-contained":true,"output-file":"afg_village_cold_percentiles.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","author":"JMR","toc-expand":1,"logo":"../images/Climat4Economist_Symbol.png","editor":"source","editor_options":{"chunk_output_type":"console"},"vignette":"%\\VignetteIndexEntry{Vignette's Title} %\\VignetteEncoding{UTF-8} %\\VignetteEngine{quarto::html}\n","toc-location":"right-body","title":"Cold percentiles in the Villages of Afghanistan"},"extensions":{"book":{"multiFile":true}}},"docx":{"identifier":{"display-name":"MS Word","target-format":"docx","base-format":"docx"},"execute":{"fig-width":5,"fig-height":4,"fig-format":"png","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"docx","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"page-width":6.5},"pandoc":{"default-image-extension":"png","to":"docx","toc":true,"toc-depth":2,"output-file":"afg_village_cold_percentiles.docx"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"author":"JMR","toc-expand":1,"logo":"../images/Climat4Economist_Symbol.png","editor":"source","editor_options":{"chunk_output_type":"console"},"vignette":"%\\VignetteIndexEntry{Vignette's Title} %\\VignetteEncoding{UTF-8} %\\VignetteEngine{quarto::html}\n","toc-location":"body","title":"Cold percentiles in the Villages of Afghanistan"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","docx"]}