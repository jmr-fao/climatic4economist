{"title":"Control Variables for the Villages of Afghanistan","markdown":{"yaml":{"title":"Control Variables for the Villages of Afghanistan","author":"JMR","toc":true,"toc-expand":1,"toc-depth":2,"format":{"html":{"self-contained":true,"code-tools":true,"toc-location":"right-body"},"docx":{"toc-location":"body"}},"editor":"source","editor_options":{"chunk_output_type":"console"},"vignette":"%\\VignetteIndexEntry{Vignette's Title} %\\VignetteEncoding{UTF-8} %\\VignetteEngine{quarto::html}\n"},"headingText":"Introduction","containsRefs":false,"markdown":"\n\nThis guide provides a step-by-step approach to extract spatial variables based on village location and the area around them.\n\n## What do I need before starting?\n\nThe following R packages are necessary: `tidyverse`, `haven`, `clock` and `terra`. To install the above package you can use `install.packages(\"name_of_package\")`, don't forget the `\"`. You also need the package `climatic4economist` which must be installed locally.\n\nIf you are not familiar with R check the [appendix] for understanding some coding style used in this tutorial.\n\n## Code\n### Set Up\n\nIn the setup, we create the paths to the various data sources and load the necessary functions for extraction. Note `..` means one step back to the folder directory, i.e. one folder back.\n\n```{r set_up}\n#| label: set_up\n\npath_to_data <- file.path(\"..\",\n                          \"..\", \"data\")\n\npath_to_village <- file.path(path_to_data, \"survey\", \"AFG\",\n                             \"Village coordinates_CoF(Village level coordinates).csv\")\n\npath_to_adm_div <- file.path(path_to_data, \"adm_div\", \"UN_borders\", \"UN-AFG-ADM2.gpkg\")\n\n\npath_to_elevation <- file.path(path_to_data, \"spatial\", \"GloFAS\",\n                               \"elevation_glofas_v4_0.nc\")\npath_to_urca <- file.path(path_to_data, \"spatial\", \"URCA\",\n                          \"URCA.tif\")\npath_to_pop <- file.path(path_to_data, \"spatial\", \"WorldPop\", \"unconstrained_UNadj_1km\",\n                         \"AFG_ppp_2020_1km_Aggregated_UNadj.tif\")\npath_to_nightlight <- file.path(path_to_data, \"spatial\", \"VIIRS\",\n                    \"VNL_npp_2024_global_vcmslcfg_v2_c202502261200.average_masked.dat.tif\")\n\npath_to_result <- file.path(path_to_data, \"result\")\n\n```\n\nWe then load the wrapper function from the package `climatic4economist`.\n\n```{r package}\n#| label: package\n\nlibrary(climatic4economist)\n```\n\n### Load the data\nLet's start by loading the data into R. As the control variables are `tif` or `nc` files we can read them with function `terra::rast()`. Note how all the data sets have the same coordinate reference system (CRS), i.e. `EPSG:4326`. This is important because in this way all the data can \"spatially\" talk to each other.\n\n```{r read_control}\n#| label: read_control\n\nelevation <- terra::rast(path_to_elevation)\nelevation\n\npop <- terra::rast(path_to_pop)\npop\n\nurca <- terra::rast(path_to_urca)\nurca\n\nnightlight <- terra::rast(path_to_nightlight)\nnightlight\n```\n\nNow we load the villages. We rename the variable for easier use.\n\n```{r read_villages}\n#| label: read_villages\n\nvillage <- data.table::fread(path_to_village) |> \n    dplyr::rename(lon = \"Longitude (X)\",\n                  lat = \"Latitude (Y)\")\nvillage\n```\n\nWe load the administrative divisions to check where the villages are. We can do this with the function `terra::vect()`. With the function `terra::aggregate()` we dissolve the polygons of each administrative divisions into a single one, i.e. the national borders.\n\n```{r read_adm_div}\n#| label: read_ad_div\n\nadm_div <- terra::vect(path_to_adm_div) |> \n    terra::aggregate(by = \"ISO3CD\")\nadm_div\n```\n\n### Georeference the survey\nAs we've mentioned, the weather data is georeferenced, so we need to ensure the same for the village data. \n\n>It is very important to check if the village and the raster data share the same coordinate reference system!\n\nUsually, the WGS 84 CRS is the default coordinate references system for coordinates. In this case it  matches the weather coordinate references system.\n\nWe also need to ensure that we can later associate the correct weather data with the right village, we do this by creating a merging variable called `ID`. This is handled by the `prepare_coord()` function, which requires the coordinates' variable names as input.\n\n```{r prepare_coord}\n#| label: prepare_coord\n\nvillage_coord <- prepare_coord(village,\n                               lon_var = lon,\n                               lat_var = lat)\nvillage_coord\n```\n\nOnce we have the unique coordinates, we are ready to transform them into spatial points using the `georef_coord()` function. When performing this transformation, it's crucial to set the correct CRS, which must match that of the weather data. The function also the coordinates' variable names as input.\n\n```{r georef_coord}\n#| label: georef_coord\nvillage_geo <- georef_coord(village_coord,\n                            geom = c(\"lon\", \"lat\"),\n                            crs = \"EPSG:4326\")\nvillage_geo\n```\n\n\n### Crop control to Afganistan\nNow we crop the control data to limit their extension to Afghanistan. This passage is not compulsory but by reducing the size of the data it makes them more manageable and more meaningful for visualization.\n\n```{r crop}\n#| label: crop\n\nelevation_afg <- terra::crop(elevation, adm_div)\nelevation_afg\n\npop_afg <- terra::crop(pop, adm_div)\npop_afg\n\nurca_afg <- terra::crop(urca, adm_div)\nurca_afg\n\nnightlight_afg <- terra::crop(nightlight, adm_div)\nnightlight_afg\n```\n\n\n### Plot\nA good practice when working with spatial data is to plot it. This is the best way to verify that everything is working as expected.\n\n```{r plot}\n#| label: plot\n\nterra::plot(elevation_afg, main = \"Elevation\")\nterra::lines(adm_div, col = \"white\", lwd = 3)\nterra::points(village_geo, col = \"red\")\n\nterra::plot(pop_afg, main = \"Population\")\nterra::lines(adm_div, col = \"black\", lwd = 3)\nterra::points(village_geo, col = \"red\")\n\nterra::plot(urca_afg, main = \"URCA\")\nterra::lines(adm_div, col = \"white\", lwd = 3)\nterra::points(village_geo, col = \"red\")\n\nterra::plot(log(1+nightlight_afg), main = \"Log Nighttime Light\")\nterra::lines(adm_div, col = \"white\", lwd = 3)\nterra::points(village_geo, col = \"red\")\n\n```\n\n### Make buffer\nWe make also a buffer around the villages to capture the HH that are part of the survey. We calculate two different radius for the buffer, 5 km and 10 km.\n\nLook how the result is very similar to the `village_geo` object. However, a careful look reveal that the buffer polygons while the villages are points.\n\n```{r buffer}\n#| label: buffer\n\nvillage_05buf <- terra::buffer(village_geo, width = 5*1000)\nvillage_05buf\n\nvillage_10buf <- terra::buffer(village_geo, width = 10*1000)\nvillage_10buf\n```\n\nBy plotting the buffer we notice how some villages are very close to each other and already a buffer of 5 km creates many overlaps.\n\n```{r plot_buf}\n#| label: plot_buf\n\nterra::plot(adm_div, col = \"grey\", main = \"Buffer 5km\")\nterra::lines(village_05buf, col = \"red\")\n\nterra::plot(adm_div, col = \"grey\", main = \"Buffer 10km\")\nterra::lines(village_10buf, col = \"blue\")\n```\n\n### Terrain characteristics from elevation data\nNow we compute some terrain indicators based on elevation. The terrain indicators are:\n\n* TRI (Terrain Ruggedness Index) is the mean of the absolute differences between the value of a cell and its 8 surrounding cells.\n\n* Slope is the average difference between the value of a cell and its 8 surrounding cells.\n\n* Roughness is the difference between the maximum and the minimum value of a cell and its 8 surrounding cells.\n\n```{r terrain}\n#| label: terrain\n\nterrain_indices <- terra::terrain(elevation_afg,\n                                  v = c(\"slope\", \"TRI\", \"roughness\"),\n                                  neighbors = 8, \n                                  unit = \"degrees\") \n\nterrain_indices\n```\n\n### Extraction\nNow we extract the spatial controls based on the village location and the buffers.\n\nWe start with the villages. Since there are many spatial variable we take advantage of the `purrr` package to apply the `extract_by_coord()` function to each one of them. To do so we first collect all the spatial variables into a list. Then we extract the values and we merge them into one data frame by combining the function`prrr::reduce()` and the function `dplyr::full_join()`.\n\nThen we rename some of the spatial variable to be more readable and we add the logarithmic transformation of the nighttime light.\n\n```{r extraction_village}\n#| label: extraction_village\n\nsp_control <- list(terrain_indices, \n                   elevation_afg, \n                   urca_afg, \n                   nightlight_afg, \n                   pop_afg)\n\nsp_control_village <- purrr::map(sp_control,\n                                 extract_by_coord,\n                                 coord = village_geo) |> \n    purrr::reduce(dplyr::full_join, by = \"ID\") |> \n    dplyr::select(-dplyr::matches(\"x_cell|y_cell\")) |> \n    dplyr::rename_with(.cols = dplyr::starts_with(\"VNL_npp\"),\n                       .fn = ~\"night_light\") |> \n    dplyr::rename_with(.cols = dplyr::starts_with(\"AFG_ppp_2020\"),\n                       .fn = ~\"pop\") |> \n    dplyr::mutate(night_light_ln = log(1 + night_light),\n                  .after = night_light)\n\nsp_control_village\n```\n\nNow we move to the buffer. The logic is the same of the extraction for the villages. The difference is that now we use the function `extract_by_poly()` for the extraction, as the buffers are polygons. This function requires an extra argument `fn_agg`. This argument tells how the values should be aggregated withing the polygon. We also separate population from the other the spatial controls as the `fn_agg` is different: we use `sum` for population and `mean` for the other variables.\n\n```{r extraction_buffer}\n#| label: extraction_buffer\n\nsp_control_mean <- list(terrain_indices, elevation_afg, nightlight_afg)\n\nsp_mean_05buf <- purrr::map(sp_control_mean,\n                            extract_by_poly,\n                            poly = village_05buf,\n                            fn_agg = \"mean\") |> \n    purrr::reduce(dplyr::full_join, by = \"ID\") |> \n    dplyr::rename_with(.cols = dplyr::starts_with(\"VNL_npp\"),\n                       .fn = ~\"night_light\") |> \n    dplyr::mutate(night_light_ln = log(1 + night_light),\n                  .after = night_light)\n\npop_05buf <- extract_by_poly(pop_afg,\n                             village_05buf,\n                             fn_agg = \"sum\") |> \n    dplyr::rename_with(.cols = dplyr::starts_with(\"AFG_ppp_2020\"),\n                       .fn = ~\"pop\")\n\nsp_mean_10buf <- purrr::map(sp_control_mean,\n                            extract_by_poly,\n                            poly = village_10buf,\n                            fn_agg = \"mean\") |> \n    purrr::reduce(dplyr::full_join, by = \"ID\") |> \n    dplyr::rename_with(.cols = dplyr::starts_with(\"VNL_npp\"),\n                       .fn = ~\"night_light\") |> \n    dplyr::mutate(night_light_ln = log(1 + night_light),\n                  .after = night_light)\n\npop_10buf <- extract_by_poly(pop_afg,\n                             village_10buf,\n                             fn_agg = \"sum\") |> \n    dplyr::rename_with(.cols = dplyr::starts_with(\"AFG_ppp_2020\"),\n                       .fn = ~\"pop\")\n```\n\n\n### Merge with villages\nNow, we combine the extracted data with the village data using `ID` as the key matching variable.\n\n```{r merge_with_village}\n#| label: merge_with_village\n\nsp_village <- merge_with_survey(village_coord, sp_control_village)\n\nsp_05buffer <- dplyr::full_join(sp_mean_05buf, pop_05buf, by = \"ID\") |> \n    merge_with_survey(village_coord, new_value = _)\n\nsp_10buffer <- dplyr::full_join(sp_mean_10buf, pop_10buf, by = \"ID\") |> \n    merge_with_survey(village_coord, new_value = _)\n```\n\n### Save\nThe final step of the code is to save the result. In this case, we save it as a `dta` file using the `haven::write_dta()` function. Then we need to  align the variables' name to the STATA format with the function `to_stata_format()`. We also remove the fifth column as the name cannot be aligned with the STATA format, and finally we save the result.\n\n```{r save}\n#| label: save\n\nsp_village |> \n  dplyr::select(-dplyr::starts_with(\"Treatment\")) |> \n  dplyr::rename_with(to_stata_format) |>\n  haven::write_dta(file.path(path_to_result, \"afg_village_sp_control.dta\"))\n\nsp_05buffer |> \n  dplyr::select(-dplyr::starts_with(\"Treatment\")) |> \n  dplyr::rename_with(to_stata_format) |>\n  haven::write_dta(file.path(path_to_result, \"afg_05buf_sp_control.dta\"))\n\nsp_10buffer |> \n  dplyr::select(-dplyr::starts_with(\"Treatment\")) |> \n  dplyr::rename_with(to_stata_format) |>\n  haven::write_dta(file.path(path_to_result, \"afg_10buf_sp_control.dta\"))\n\n```\n\n\n## Appendix\n### New to R? Read this first!\n#### The pipe command\n\nThe pipe command `|>`. It lets you pass the result of one expression as the first argument to the next. It creates a fluid chain of functions.\n\nInstead of nesting functions inside each other, you can pipe the output forward, making the code easier to read.\n\n```{r}\n4 |> log() |> exp()\n\nexp(log(4))\n```\n\nNote:\n\n* The base R pipe `|>` was introduced in R 4.1.0.\n\n* In some tutorials, you might also see `%>%`, which comes from the `magrittr` or `dplyr` packages. Both do a similar thing, but `|>` is now the official base R version.\n\n#### The package namespaces\nIn R, namespaces help organize functions inside packages.\n\nYou can use a function from a specific package by writing: `package_name::function_name()`. \n\nAs the name suggests, namespaces provide \"spaces\" for \"names\", it tells R exactly where to find a function. They provide a context for looking up the value of an object associated with a name. When we write `terra::vect()` we are asking R to look for the function `vect()` in the `terra` package.\n\nThis is a fairly advanced topic, and by-and-large, not that important! When you first start using namespaces, it'll seem like a lot of work for little gain. However, having a high quality namespace helps encapsulate your package and makes it self-contained. This ensures that other packages won't interfere with your code, that your code won't interfere with other packages, and that your package works regardless of the environment in which it's run.\n\nYou don't always need to write the namespace every time. A very common practice is to load the necessary packages at the beginning of your script (in the set up section for example) with `library()`. This is actually the most known and common approach. \n\nTo do so just add `library(name_of_package)`, for example `library(terra)`. Then we can just call the function without the name space, like this `vect()`.\n\n#### The assign operator\n\nThe assign operator `<-`. This is a peculiarity of R and it is used to assign values to variables. However, `<-` is preferred in R scripts because it makes assignments visually distinct from comparisons (`==`) and function arguments (`=`).\n\nNote that the operators `<-` and `=` can be used, almost interchangeably. However, inside function calls, you should use `=` to name arguments.\n\n#### Functions\nIn Stata, you're used to running do-files or programs to automate tasks. In R, functions play a similar role: they help you organize code and reuse it easily.\n\nA function in R looks like this:\n```{r fn_body}\n#| labek: fn_body\n#| eval: false\n\nmy_function <- function(input1, input2) {\n  # Do something with the inputs\n  result <- input1 + input2\n  return(result)\n}\n```\n\n* `my_function` is the function's name.\n\n* `function(input1, input2)` defines what inputs (arguments) it takes.\n\n* Inside `{}`, you write the code that runs when you call the function.\n\n* `return(result)` tells R what the output should be.\n\nYou call the function like this:\n```{r fn_out}\n#| label: fn_out\n#| eval: false\n\nmy_function(3, 5)\n# Output: 8\n```\n\nNote that you can change the order of the inputs if you properly label them.\n```{r fn_out2}\n#| label: fn_out2\n#| eval: false\n\nmy_function(input2 = 5, input1 = 3)\n# Output: 8\n```\n\nKey points for Stata users:\n\n* Functions in R must be assigned to a name using <- (the assignment operator).\n\n* You can think of functions a little like Stata's program define, but in R, every function can return a value to be used later.\n\n* You can nest functions inside other code, making your analysis scripts cleaner and easier to read.\n\n\n### Want to know about the data?\n\n#### Elevation\nElevation from the auxiliary variables of GloFAS. The value are the mean height elevation above sea level for each pixel.\n\n| Parameter           | Value                   |\n|:--------------------|:-----------------------:|\n| spatial resolution  | 0.03° x 0.03° lon lat   |\n| temporal resolution | 1981-2010               |\n| unit of measure     | m                       |\n\nIt is possible to find additional information [here](https://cds.climate.copernicus.eu/cdsapp#!/dataset/cems-glofas-forecast?tab=overview) and the technical and information [here](https://www.globalfloods.eu/technical-information/products/). \nThe data can be freely download from [here](https://confluence.ecmwf.int/display/CEMS/Auxiliary+Data).\n\n    \n#### Population\nWorldPop: Estimated number of people per pixel.\n\nThe units are number of people per pixel with country totals adjusted to match the corresponding official United Nations population estimates that have been prepared by the Population Division of the Department of Economic and Social Affairs of the United Nations Secretariat. The mapping approach is Random Forest-based dasymetric redistribution,\n\n| Parameter           | Value                   |\n|:--------------------|:-----------------------:|\n| spatial resolution  | 30 arc second (~1km)    |\n| temporal resolution | yearly                  |\n| time frame          | 2020                    |\n| unit of measure     | number of people        |\n\nIt is possible to find additional information [here]( https://www.worldpop.org/methods/top_down_constrained_vs_unconstrained/) and the technical and information [here](https://www.worldpop.org/methods/populations/). \nThe data can be freely download from [here](https://hub.worldpop.org/geodata/summary?id=34984).\n\n\n#### URCA\nThe 30 urban–rural catchment areas show the catchment areas around cities and towns of different sizes (the no data value is 128). Each rural pixel is assigned to one defined travel time category to one of seven urban agglomeration sizes.\n\n| Parameter           | Value                   |\n|:--------------------|:-----------------------:|\n| spatial resolution  | 0.03° x 0.03° lon lat   |\n| temporal resolution | yearly                  |\n| time frame          | 2015                    |\n| unit of measure     | travel time category    |\n\nIt is possible to find additional information [here](https://www.pnas.org/doi/full/10.1073/pnas.2011990118). \nThe data can be freely download from [here](https://figshare.com/articles/dataset/Urban-rural_continuum/12579572).\n\n\n#### Nighttime light\nVIIRS nighttime lights (VNL) version V2.1: annual values obtained by from the monthly averages with filtering to remove extraneous features such as biomass burning, aurora, and background.\n\n| Parameter           | Value                     |\n|:--------------------|:-------------------------:|\n| spatial resolution  | 15 arc second             |\n| temporal resolution | year                      |\n| time frame          | 2024                      |\n| unit of measure     | nW/cm2/sr, average-masked |\n\n\nIt is possible to find additional information [here](https://eogdata.mines.edu/products/vnl/). \nThe data can be freely download from [here](https://eogdata.mines.edu/nighttime_light/annual/v21/).\n\n","srcMarkdownNoYaml":"\n\n## Introduction\nThis guide provides a step-by-step approach to extract spatial variables based on village location and the area around them.\n\n## What do I need before starting?\n\nThe following R packages are necessary: `tidyverse`, `haven`, `clock` and `terra`. To install the above package you can use `install.packages(\"name_of_package\")`, don't forget the `\"`. You also need the package `climatic4economist` which must be installed locally.\n\nIf you are not familiar with R check the [appendix] for understanding some coding style used in this tutorial.\n\n## Code\n### Set Up\n\nIn the setup, we create the paths to the various data sources and load the necessary functions for extraction. Note `..` means one step back to the folder directory, i.e. one folder back.\n\n```{r set_up}\n#| label: set_up\n\npath_to_data <- file.path(\"..\",\n                          \"..\", \"data\")\n\npath_to_village <- file.path(path_to_data, \"survey\", \"AFG\",\n                             \"Village coordinates_CoF(Village level coordinates).csv\")\n\npath_to_adm_div <- file.path(path_to_data, \"adm_div\", \"UN_borders\", \"UN-AFG-ADM2.gpkg\")\n\n\npath_to_elevation <- file.path(path_to_data, \"spatial\", \"GloFAS\",\n                               \"elevation_glofas_v4_0.nc\")\npath_to_urca <- file.path(path_to_data, \"spatial\", \"URCA\",\n                          \"URCA.tif\")\npath_to_pop <- file.path(path_to_data, \"spatial\", \"WorldPop\", \"unconstrained_UNadj_1km\",\n                         \"AFG_ppp_2020_1km_Aggregated_UNadj.tif\")\npath_to_nightlight <- file.path(path_to_data, \"spatial\", \"VIIRS\",\n                    \"VNL_npp_2024_global_vcmslcfg_v2_c202502261200.average_masked.dat.tif\")\n\npath_to_result <- file.path(path_to_data, \"result\")\n\n```\n\nWe then load the wrapper function from the package `climatic4economist`.\n\n```{r package}\n#| label: package\n\nlibrary(climatic4economist)\n```\n\n### Load the data\nLet's start by loading the data into R. As the control variables are `tif` or `nc` files we can read them with function `terra::rast()`. Note how all the data sets have the same coordinate reference system (CRS), i.e. `EPSG:4326`. This is important because in this way all the data can \"spatially\" talk to each other.\n\n```{r read_control}\n#| label: read_control\n\nelevation <- terra::rast(path_to_elevation)\nelevation\n\npop <- terra::rast(path_to_pop)\npop\n\nurca <- terra::rast(path_to_urca)\nurca\n\nnightlight <- terra::rast(path_to_nightlight)\nnightlight\n```\n\nNow we load the villages. We rename the variable for easier use.\n\n```{r read_villages}\n#| label: read_villages\n\nvillage <- data.table::fread(path_to_village) |> \n    dplyr::rename(lon = \"Longitude (X)\",\n                  lat = \"Latitude (Y)\")\nvillage\n```\n\nWe load the administrative divisions to check where the villages are. We can do this with the function `terra::vect()`. With the function `terra::aggregate()` we dissolve the polygons of each administrative divisions into a single one, i.e. the national borders.\n\n```{r read_adm_div}\n#| label: read_ad_div\n\nadm_div <- terra::vect(path_to_adm_div) |> \n    terra::aggregate(by = \"ISO3CD\")\nadm_div\n```\n\n### Georeference the survey\nAs we've mentioned, the weather data is georeferenced, so we need to ensure the same for the village data. \n\n>It is very important to check if the village and the raster data share the same coordinate reference system!\n\nUsually, the WGS 84 CRS is the default coordinate references system for coordinates. In this case it  matches the weather coordinate references system.\n\nWe also need to ensure that we can later associate the correct weather data with the right village, we do this by creating a merging variable called `ID`. This is handled by the `prepare_coord()` function, which requires the coordinates' variable names as input.\n\n```{r prepare_coord}\n#| label: prepare_coord\n\nvillage_coord <- prepare_coord(village,\n                               lon_var = lon,\n                               lat_var = lat)\nvillage_coord\n```\n\nOnce we have the unique coordinates, we are ready to transform them into spatial points using the `georef_coord()` function. When performing this transformation, it's crucial to set the correct CRS, which must match that of the weather data. The function also the coordinates' variable names as input.\n\n```{r georef_coord}\n#| label: georef_coord\nvillage_geo <- georef_coord(village_coord,\n                            geom = c(\"lon\", \"lat\"),\n                            crs = \"EPSG:4326\")\nvillage_geo\n```\n\n\n### Crop control to Afganistan\nNow we crop the control data to limit their extension to Afghanistan. This passage is not compulsory but by reducing the size of the data it makes them more manageable and more meaningful for visualization.\n\n```{r crop}\n#| label: crop\n\nelevation_afg <- terra::crop(elevation, adm_div)\nelevation_afg\n\npop_afg <- terra::crop(pop, adm_div)\npop_afg\n\nurca_afg <- terra::crop(urca, adm_div)\nurca_afg\n\nnightlight_afg <- terra::crop(nightlight, adm_div)\nnightlight_afg\n```\n\n\n### Plot\nA good practice when working with spatial data is to plot it. This is the best way to verify that everything is working as expected.\n\n```{r plot}\n#| label: plot\n\nterra::plot(elevation_afg, main = \"Elevation\")\nterra::lines(adm_div, col = \"white\", lwd = 3)\nterra::points(village_geo, col = \"red\")\n\nterra::plot(pop_afg, main = \"Population\")\nterra::lines(adm_div, col = \"black\", lwd = 3)\nterra::points(village_geo, col = \"red\")\n\nterra::plot(urca_afg, main = \"URCA\")\nterra::lines(adm_div, col = \"white\", lwd = 3)\nterra::points(village_geo, col = \"red\")\n\nterra::plot(log(1+nightlight_afg), main = \"Log Nighttime Light\")\nterra::lines(adm_div, col = \"white\", lwd = 3)\nterra::points(village_geo, col = \"red\")\n\n```\n\n### Make buffer\nWe make also a buffer around the villages to capture the HH that are part of the survey. We calculate two different radius for the buffer, 5 km and 10 km.\n\nLook how the result is very similar to the `village_geo` object. However, a careful look reveal that the buffer polygons while the villages are points.\n\n```{r buffer}\n#| label: buffer\n\nvillage_05buf <- terra::buffer(village_geo, width = 5*1000)\nvillage_05buf\n\nvillage_10buf <- terra::buffer(village_geo, width = 10*1000)\nvillage_10buf\n```\n\nBy plotting the buffer we notice how some villages are very close to each other and already a buffer of 5 km creates many overlaps.\n\n```{r plot_buf}\n#| label: plot_buf\n\nterra::plot(adm_div, col = \"grey\", main = \"Buffer 5km\")\nterra::lines(village_05buf, col = \"red\")\n\nterra::plot(adm_div, col = \"grey\", main = \"Buffer 10km\")\nterra::lines(village_10buf, col = \"blue\")\n```\n\n### Terrain characteristics from elevation data\nNow we compute some terrain indicators based on elevation. The terrain indicators are:\n\n* TRI (Terrain Ruggedness Index) is the mean of the absolute differences between the value of a cell and its 8 surrounding cells.\n\n* Slope is the average difference between the value of a cell and its 8 surrounding cells.\n\n* Roughness is the difference between the maximum and the minimum value of a cell and its 8 surrounding cells.\n\n```{r terrain}\n#| label: terrain\n\nterrain_indices <- terra::terrain(elevation_afg,\n                                  v = c(\"slope\", \"TRI\", \"roughness\"),\n                                  neighbors = 8, \n                                  unit = \"degrees\") \n\nterrain_indices\n```\n\n### Extraction\nNow we extract the spatial controls based on the village location and the buffers.\n\nWe start with the villages. Since there are many spatial variable we take advantage of the `purrr` package to apply the `extract_by_coord()` function to each one of them. To do so we first collect all the spatial variables into a list. Then we extract the values and we merge them into one data frame by combining the function`prrr::reduce()` and the function `dplyr::full_join()`.\n\nThen we rename some of the spatial variable to be more readable and we add the logarithmic transformation of the nighttime light.\n\n```{r extraction_village}\n#| label: extraction_village\n\nsp_control <- list(terrain_indices, \n                   elevation_afg, \n                   urca_afg, \n                   nightlight_afg, \n                   pop_afg)\n\nsp_control_village <- purrr::map(sp_control,\n                                 extract_by_coord,\n                                 coord = village_geo) |> \n    purrr::reduce(dplyr::full_join, by = \"ID\") |> \n    dplyr::select(-dplyr::matches(\"x_cell|y_cell\")) |> \n    dplyr::rename_with(.cols = dplyr::starts_with(\"VNL_npp\"),\n                       .fn = ~\"night_light\") |> \n    dplyr::rename_with(.cols = dplyr::starts_with(\"AFG_ppp_2020\"),\n                       .fn = ~\"pop\") |> \n    dplyr::mutate(night_light_ln = log(1 + night_light),\n                  .after = night_light)\n\nsp_control_village\n```\n\nNow we move to the buffer. The logic is the same of the extraction for the villages. The difference is that now we use the function `extract_by_poly()` for the extraction, as the buffers are polygons. This function requires an extra argument `fn_agg`. This argument tells how the values should be aggregated withing the polygon. We also separate population from the other the spatial controls as the `fn_agg` is different: we use `sum` for population and `mean` for the other variables.\n\n```{r extraction_buffer}\n#| label: extraction_buffer\n\nsp_control_mean <- list(terrain_indices, elevation_afg, nightlight_afg)\n\nsp_mean_05buf <- purrr::map(sp_control_mean,\n                            extract_by_poly,\n                            poly = village_05buf,\n                            fn_agg = \"mean\") |> \n    purrr::reduce(dplyr::full_join, by = \"ID\") |> \n    dplyr::rename_with(.cols = dplyr::starts_with(\"VNL_npp\"),\n                       .fn = ~\"night_light\") |> \n    dplyr::mutate(night_light_ln = log(1 + night_light),\n                  .after = night_light)\n\npop_05buf <- extract_by_poly(pop_afg,\n                             village_05buf,\n                             fn_agg = \"sum\") |> \n    dplyr::rename_with(.cols = dplyr::starts_with(\"AFG_ppp_2020\"),\n                       .fn = ~\"pop\")\n\nsp_mean_10buf <- purrr::map(sp_control_mean,\n                            extract_by_poly,\n                            poly = village_10buf,\n                            fn_agg = \"mean\") |> \n    purrr::reduce(dplyr::full_join, by = \"ID\") |> \n    dplyr::rename_with(.cols = dplyr::starts_with(\"VNL_npp\"),\n                       .fn = ~\"night_light\") |> \n    dplyr::mutate(night_light_ln = log(1 + night_light),\n                  .after = night_light)\n\npop_10buf <- extract_by_poly(pop_afg,\n                             village_10buf,\n                             fn_agg = \"sum\") |> \n    dplyr::rename_with(.cols = dplyr::starts_with(\"AFG_ppp_2020\"),\n                       .fn = ~\"pop\")\n```\n\n\n### Merge with villages\nNow, we combine the extracted data with the village data using `ID` as the key matching variable.\n\n```{r merge_with_village}\n#| label: merge_with_village\n\nsp_village <- merge_with_survey(village_coord, sp_control_village)\n\nsp_05buffer <- dplyr::full_join(sp_mean_05buf, pop_05buf, by = \"ID\") |> \n    merge_with_survey(village_coord, new_value = _)\n\nsp_10buffer <- dplyr::full_join(sp_mean_10buf, pop_10buf, by = \"ID\") |> \n    merge_with_survey(village_coord, new_value = _)\n```\n\n### Save\nThe final step of the code is to save the result. In this case, we save it as a `dta` file using the `haven::write_dta()` function. Then we need to  align the variables' name to the STATA format with the function `to_stata_format()`. We also remove the fifth column as the name cannot be aligned with the STATA format, and finally we save the result.\n\n```{r save}\n#| label: save\n\nsp_village |> \n  dplyr::select(-dplyr::starts_with(\"Treatment\")) |> \n  dplyr::rename_with(to_stata_format) |>\n  haven::write_dta(file.path(path_to_result, \"afg_village_sp_control.dta\"))\n\nsp_05buffer |> \n  dplyr::select(-dplyr::starts_with(\"Treatment\")) |> \n  dplyr::rename_with(to_stata_format) |>\n  haven::write_dta(file.path(path_to_result, \"afg_05buf_sp_control.dta\"))\n\nsp_10buffer |> \n  dplyr::select(-dplyr::starts_with(\"Treatment\")) |> \n  dplyr::rename_with(to_stata_format) |>\n  haven::write_dta(file.path(path_to_result, \"afg_10buf_sp_control.dta\"))\n\n```\n\n\n## Appendix\n### New to R? Read this first!\n#### The pipe command\n\nThe pipe command `|>`. It lets you pass the result of one expression as the first argument to the next. It creates a fluid chain of functions.\n\nInstead of nesting functions inside each other, you can pipe the output forward, making the code easier to read.\n\n```{r}\n4 |> log() |> exp()\n\nexp(log(4))\n```\n\nNote:\n\n* The base R pipe `|>` was introduced in R 4.1.0.\n\n* In some tutorials, you might also see `%>%`, which comes from the `magrittr` or `dplyr` packages. Both do a similar thing, but `|>` is now the official base R version.\n\n#### The package namespaces\nIn R, namespaces help organize functions inside packages.\n\nYou can use a function from a specific package by writing: `package_name::function_name()`. \n\nAs the name suggests, namespaces provide \"spaces\" for \"names\", it tells R exactly where to find a function. They provide a context for looking up the value of an object associated with a name. When we write `terra::vect()` we are asking R to look for the function `vect()` in the `terra` package.\n\nThis is a fairly advanced topic, and by-and-large, not that important! When you first start using namespaces, it'll seem like a lot of work for little gain. However, having a high quality namespace helps encapsulate your package and makes it self-contained. This ensures that other packages won't interfere with your code, that your code won't interfere with other packages, and that your package works regardless of the environment in which it's run.\n\nYou don't always need to write the namespace every time. A very common practice is to load the necessary packages at the beginning of your script (in the set up section for example) with `library()`. This is actually the most known and common approach. \n\nTo do so just add `library(name_of_package)`, for example `library(terra)`. Then we can just call the function without the name space, like this `vect()`.\n\n#### The assign operator\n\nThe assign operator `<-`. This is a peculiarity of R and it is used to assign values to variables. However, `<-` is preferred in R scripts because it makes assignments visually distinct from comparisons (`==`) and function arguments (`=`).\n\nNote that the operators `<-` and `=` can be used, almost interchangeably. However, inside function calls, you should use `=` to name arguments.\n\n#### Functions\nIn Stata, you're used to running do-files or programs to automate tasks. In R, functions play a similar role: they help you organize code and reuse it easily.\n\nA function in R looks like this:\n```{r fn_body}\n#| labek: fn_body\n#| eval: false\n\nmy_function <- function(input1, input2) {\n  # Do something with the inputs\n  result <- input1 + input2\n  return(result)\n}\n```\n\n* `my_function` is the function's name.\n\n* `function(input1, input2)` defines what inputs (arguments) it takes.\n\n* Inside `{}`, you write the code that runs when you call the function.\n\n* `return(result)` tells R what the output should be.\n\nYou call the function like this:\n```{r fn_out}\n#| label: fn_out\n#| eval: false\n\nmy_function(3, 5)\n# Output: 8\n```\n\nNote that you can change the order of the inputs if you properly label them.\n```{r fn_out2}\n#| label: fn_out2\n#| eval: false\n\nmy_function(input2 = 5, input1 = 3)\n# Output: 8\n```\n\nKey points for Stata users:\n\n* Functions in R must be assigned to a name using <- (the assignment operator).\n\n* You can think of functions a little like Stata's program define, but in R, every function can return a value to be used later.\n\n* You can nest functions inside other code, making your analysis scripts cleaner and easier to read.\n\n\n### Want to know about the data?\n\n#### Elevation\nElevation from the auxiliary variables of GloFAS. The value are the mean height elevation above sea level for each pixel.\n\n| Parameter           | Value                   |\n|:--------------------|:-----------------------:|\n| spatial resolution  | 0.03° x 0.03° lon lat   |\n| temporal resolution | 1981-2010               |\n| unit of measure     | m                       |\n\nIt is possible to find additional information [here](https://cds.climate.copernicus.eu/cdsapp#!/dataset/cems-glofas-forecast?tab=overview) and the technical and information [here](https://www.globalfloods.eu/technical-information/products/). \nThe data can be freely download from [here](https://confluence.ecmwf.int/display/CEMS/Auxiliary+Data).\n\n    \n#### Population\nWorldPop: Estimated number of people per pixel.\n\nThe units are number of people per pixel with country totals adjusted to match the corresponding official United Nations population estimates that have been prepared by the Population Division of the Department of Economic and Social Affairs of the United Nations Secretariat. The mapping approach is Random Forest-based dasymetric redistribution,\n\n| Parameter           | Value                   |\n|:--------------------|:-----------------------:|\n| spatial resolution  | 30 arc second (~1km)    |\n| temporal resolution | yearly                  |\n| time frame          | 2020                    |\n| unit of measure     | number of people        |\n\nIt is possible to find additional information [here]( https://www.worldpop.org/methods/top_down_constrained_vs_unconstrained/) and the technical and information [here](https://www.worldpop.org/methods/populations/). \nThe data can be freely download from [here](https://hub.worldpop.org/geodata/summary?id=34984).\n\n\n#### URCA\nThe 30 urban–rural catchment areas show the catchment areas around cities and towns of different sizes (the no data value is 128). Each rural pixel is assigned to one defined travel time category to one of seven urban agglomeration sizes.\n\n| Parameter           | Value                   |\n|:--------------------|:-----------------------:|\n| spatial resolution  | 0.03° x 0.03° lon lat   |\n| temporal resolution | yearly                  |\n| time frame          | 2015                    |\n| unit of measure     | travel time category    |\n\nIt is possible to find additional information [here](https://www.pnas.org/doi/full/10.1073/pnas.2011990118). \nThe data can be freely download from [here](https://figshare.com/articles/dataset/Urban-rural_continuum/12579572).\n\n\n#### Nighttime light\nVIIRS nighttime lights (VNL) version V2.1: annual values obtained by from the monthly averages with filtering to remove extraneous features such as biomass burning, aurora, and background.\n\n| Parameter           | Value                     |\n|:--------------------|:-------------------------:|\n| spatial resolution  | 15 arc second             |\n| temporal resolution | year                      |\n| time frame          | 2024                      |\n| unit of measure     | nW/cm2/sr, average-masked |\n\n\nIt is possible to find additional information [here](https://eogdata.mines.edu/products/vnl/). \nThe data can be freely download from [here](https://eogdata.mines.edu/nighttime_light/annual/v21/).\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":2,"self-contained":true,"output-file":"afg_village_control.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","author":"JMR","toc-expand":1,"logo":"../images/Climat4Economist_Symbol.png","editor":"source","editor_options":{"chunk_output_type":"console"},"vignette":"%\\VignetteIndexEntry{Vignette's Title} %\\VignetteEncoding{UTF-8} %\\VignetteEngine{quarto::html}\n","toc-location":"right-body","title":"Control Variables for the Villages of Afghanistan"},"extensions":{"book":{"multiFile":true}}},"docx":{"identifier":{"display-name":"MS Word","target-format":"docx","base-format":"docx"},"execute":{"fig-width":5,"fig-height":4,"fig-format":"png","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"docx","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"page-width":6.5},"pandoc":{"default-image-extension":"png","to":"docx","toc":true,"toc-depth":2,"output-file":"afg_village_control.docx"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"author":"JMR","toc-expand":1,"logo":"../images/Climat4Economist_Symbol.png","editor":"source","editor_options":{"chunk_output_type":"console"},"vignette":"%\\VignetteIndexEntry{Vignette's Title} %\\VignetteEncoding{UTF-8} %\\VignetteEngine{quarto::html}\n","toc-location":"body","title":"Control Variables for the Villages of Afghanistan"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","docx"]}