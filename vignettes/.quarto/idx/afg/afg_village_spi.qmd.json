{"title":"SPI for the Afghanistan villages","markdown":{"yaml":{"title":"SPI for the Afghanistan villages","author":"JMR","toc":true,"toc-expand":1,"toc-depth":3,"format":{"html":{"self-contained":true,"code-tools":true,"toc-location":"right-body"},"docx":{"toc-location":"body"}},"editor":"source","editor_options":{"chunk_output_type":"console"},"vignette":"%\\VignetteIndexEntry{Vignette's Title} %\\VignetteEncoding{UTF-8} %\\VignetteEngine{quarto::html}\n"},"headingText":"Introduction","containsRefs":false,"markdown":"\n\nThis guide provides a step-by-step approach to compute the Standardized Precipitation Index (SPI) based on village locations. \n\n## What do I need before starting?\n\nThe following R packages are necessary: `tidyverse`, `haven`, `SPEI`, `furrr`, `clock` and `terra`. To install the above package you can use `install.packages(\"name_of_package\")`, don't forget the `\"`. You also need the package `climatic4economist` which must be installed locally.\n\nIf you are not familiar with R check the [appendix] for understanding some coding style used in this tutorial.\n\n## Code\n### Set Up\n\nIn the setup, we create the paths to the various data sources and load the necessary functions for extraction. Note `..` means one step back to the folder directory, i.e. one folder back.\n\n```{r set_up}\n#| label: set_up\n\npath_to_data <- file.path(#\"..\",\n                          \"..\", \"data\")\n\npath_to_tpr <- file.path(path_to_data, \"weather\", \"ERA5_Land\", \n                         \"AFG\", \"monthly\", \"monthly_tpr_1970_2024\")\npath_to_tpr <- file.path(path_to_data, \"weather\", \"ERA5_Land\", \n                         \"AFG\", \"monthly\", \"month_50_25_2m_tpr.nc\")\npath_to_village <- file.path(path_to_data, \"survey\", \"AFG\",\n                             \"Village coordinates_CoF(Village level coordinates).csv\")\n\npath_to_adm_div <- file.path(path_to_data, \"adm_div\", \"UN_borders\", \"UN-AFG-ADM2.gpkg\")\n\npath_to_result <- file.path(path_to_data, \"result\")\n\n```\n\nWe load also the package `climatic4economist` wich contains a series of wrapped functions to ease the computation.\n\n```{r package}\n#| label: package\n\nlibrary(climatic4economist)\n```\n\n\n### Load the data\n#### Weather data\nLet's start by loading the data into R. We load the weather observation with the function `terra::rast()`. As the raw data is made of two different files, we first load each one and then we combine with `c()` function.\n\n```{r read_weather}\n#| label: read_weather\n\n# tpr_0 <- terra::rast(file.path(path_to_tpr, \"data_0.nc\"))\n# tpr_1 <- terra::rast(file.path(path_to_tpr, \"data_1.nc\"))\n# tpr_all <- c(tpr_0, tpr_1)\n\ntpr_all <- terra::rast(path_to_tpr)\n\n```\n\nNote that there is no metadata for the time of the observations. We have this information in the names of the raster layers.\n\n```{r time}\n#| label: time\nterra::time(tpr_all) |> head()\nnames(tpr_all) |> head()\n```\n\nHowever, the information is not ready to be used as it indicates seconds from 1970 (indeed the first observation have a negative sign as they refer to date before 1970).\n\nWe need to change the seconds into proper dates and set the names of the layers as the date of observation. This is very important for later.\n\nNote that the layers are not correctly ordered, we change this with the function `tidyterra::relocate()`.\n\n```{r second_to_date}\n#| label: second_to_date\n\nreference_period <- second_to_date(names(tpr_all))\nreference_period |> tail()\nreference_period |> head()\n\nnames(tpr_all) <- reference_period\ntpr_all\n```\n\n#### Village locations\nNow we load the villages. We rename the variable for easier use.\n\n```{r read_villages}\n#| label: read_villages\n\nvillage <- data.table::fread(path_to_village) |> \n    dplyr::rename(lon = \"Longitude (X)\",\n                  lat = \"Latitude (Y)\")\nvillage\n```\n\nWe load also the administrative divisions to check where the villages are.\n\n```{r read_adm_div}\n#| label: read_ad_div\n\nadm_div <- terra::vect(path_to_adm_div)\nadm_div\n```\n\n### Georeference the village\n\nAs we've mentioned, the weather data is georeferenced, so we need to ensure the same for the village data. \n\n>It is very important to check if the village and the raster data share the same coordinate reference system!\n\nUsually, the WGS 84 CRS is the default coordinate references system for coordinates. In this case it  matches the weather coordinate references system.\n\nWe also need to ensure that we can later associate the correct weather data with the right village, we do this by creating a merging variable called `ID`. This is handled by the `prepare_coord()` function, which requires the coordinates' variable names as input.\n\n```{r prepare_coord}\n#| label: prepare_coord\n\nvillage_coord <- prepare_coord(village,\n                               lon_var = lon,\n                               lat_var = lat)\nvillage_coord\n```\n\nOnce we have the unique coordinates, we are ready to transform them into spatial points using the `georef_coord()` function. When performing this transformation, it's crucial to set the correct CRS, which must match that of the weather data. The function also the coordinates' variable names as input.\n\n```{r georef_coord}\n#| label: georef_coord\nvillage_geo <- georef_coord(village_coord,\n                            geom = c(\"lon\", \"lat\"),\n                            crs = \"EPSG:4326\")\nvillage_geo\n```\n\n\n### Plot\nA good practice when working with spatial data is to plot it. This is the best way to verify that everything is working as expected.\n\nFirst, we plot the administrative division and the villages to ensure they are correctly located and we examine their spatial distribution. \n\n```{r plot_survey_geo}\n#| label: plot_survey_geo\n\nterra::plot(adm_div, \n            col = \"grey80\",\n            border=\"grey60\",\n            lwd = 0.1,\n            main = \"Afganistan's District and Programme Villages\")\nterra::points(village_geo, col = \"blue\", cex = 1)\n\nvillage_geo |> \n    tidyterra::filter(ID == 47) |> \n    terra::text(\"ID\", col = \"red\")\n```\n\nWe can see that the village `ID == 47` is isolated fro the other villages, which tend to cluster in two distinct areas. I would suggest to double check the accuracy of this village.\n\n```{r oulier}\n#| label: oulier\n\nvillage_coord |> \n    dplyr::filter(ID == 47) |> \n    knitr::kable()\n```\n\nNext, we plot a layer of the monthly precipitation data to see how it overlaps with the spatial coordinates.\n\n```{r plot_precipitation}\n#| label: plot_precipitation\n\nterra::plot(tpr_all, \"2023-12-01\", col = terra::map.pal(\"water\"),\n            main = \"Monthly precipitation on 2023-12-01 and village locations\")\nterra::points(village_geo, col = \"gold\", cex = 0.8)\n```\n\nOnce again, the villages coordinates align with the temperature data, which is great!\n\n### Extract\nNext, we extract the weather data based on the village coordinates using the `extract_by_coord()` function. This function requires the raster with the weather data and the georeferenced coordinates as inputs.\n\nLooking at the result, we see first the `ID` column, that identifies the village coordinates. The second and third column are the coordinates of the associated cells.\n\n```{r extract_tmin}\n#| label: extract_tmin\n\ntpre_village_m <- extract_by_coord(raster = tpr_all, \n                                   coord = village_geo)\ntpre_village_m\n\n```\n\nAgain we have a row for each unique village. However, if we want to know how many different cells there are we can look unique cell coordinates.\n\n```{r cell_coordinate}\n#| label: cell_coordinate\n\nunique_cell <- tpre_village_m |>\n  dplyr::distinct(x_cell, y_cell)\nnrow(unique_cell)\n```\n\nWe see that now the number of rows is `r nrow(unique_cell)`, this is the actual different weather observation that we can merge with the villages. In other words, many villages share the same weather observation as they fall within the same pixel.\n\n\n### Prepare data\nThe original unit of measure is in meters, we change it into milliliters to ease the interpretation.\n\n```{r transformation}\n#| label: transformation\n\ntpre_village_mm <- tpre_village_m |>\n  dplyr::mutate(dplyr::across(.cols = dplyr::matches(\"[0-9]{4}\"),\n                              .fns = ~ .x *1000))\n```\n\n\n### Compute the SPI\nWe now compute the SPI with the function `compute_spi()`. This function requires the precipitation time series for each location and the time scale at which the SPI is computed.\n\nTo compute the SPI, it is recommended to use at least 30 years of observation to ensure a good estimation of the parameters. More years can strength the estimation but the results can be affected by climate change: if there have been a change in the climate parameters, old observations might be not indicative of the current situation affecting the estimation. There are no clear rule on this, so we leave the possibility to select the time range of observation with the function `select_by_dates()`.\n\nThe function `select_by_dates()` requires both or just one between the starting date, `from`, and the end date `to`. If both are provide the the function select between the two dates, if only `from` is provided the function selects all date after, and if only `to` is provided the function selects all date before. To know more look for the help page or run `?select_by_dates`.\n\nLooking at the result, we see first is the `ID` column, that we will use to merge back with the survey. The other columns contain the SPI observations over time specific to each coordinate.\n\n```{r compute_spi1}\n#| label: compute_spi1\n#| warning: false\n\nspi1 <- compute_spi(tpre_village_mm, time_scale = 1)\nspi1\n```\n\nWhen we select a time scale grater than one, we can see that the first observations are missing, this is because the SPI left average the months indicated by the time scale.\n\n```{r compute_spi}\n#| label: compute_spi\n#| warning: false\n\nspi3 <- compute_spi(tpre_village_mm, time_scale = 3)\nspi3\n```\n\n### Merge with survey\nNow, we combine the extracted weather data with the village data using `ID` as the key matching variable.\n\nIf we want to select just a subsets of observations we can use the `select_by_dates()` function. \n\nIf we want to select based on the date of interview of the survey, we can use `select_by_interview()`.\n\n```{r merge_spi}\n#| label: merge_spi\n\nspi3_village <- merge_with_survey(village_coord, spi3)\nspi3_village_22_24 <- select_by_interview(df = spi3_village,\n                                          interview = \"2024-09-21\",\n                                          interval = \"2 year\")\nspi3_village_22_24\n\nspi1_village <- merge_with_survey(village_coord, spi1)\nspi1_village_22_24 <- select_by_interview(df = spi1_village,\n                                          interview = \"2024-09-21\",\n                                          interval = \"2 year\")\nspi1_village_22_24\n```\n\n\n### Save\n\nThe final step of the code is to save the result. In this case, we save it as a `dta` file using the `haven::write_dta()` function. Then we need to  align the variables' name to the STATA format with the function `to_stata_format()`. We also remove the fifth column as the name cannot be aligned with the STATA format, and finally we save the result.\n\n```{r write_data}\n#| label: write_data\n\nspi1_village_22_24 |> \n  dplyr::select(-dplyr::starts_with(\"Treatment\")) |> \n  dplyr::rename_with(to_stata_format) |>\n  haven::write_dta(file.path(path_to_result, \"afg_village_spi1.dta\"))\n\nspi3_village_22_24 |> \n  dplyr::select(-dplyr::starts_with(\"Treatment\")) |> \n  dplyr::rename_with(to_stata_format) |>\n  haven::write_dta(file.path(path_to_result, \"afg_village_spi3.dta\"))\n\n```\n\n## Appendix\n### New to R? Read this first!\n#### The pipe command\n\nThe pipe command `|>`. It lets you pass the result of one expression as the first argument to the next. It creates a fluid chain of functions.\n\nInstead of nesting functions inside each other, you can pipe the output forward, making the code easier to read.\n\n```{r}\n4 |> log() |> exp()\n\nexp(log(4))\n```\n\nNote:\n\n* The base R pipe `|>` was introduced in R 4.1.0.\n\n* In some tutorials, you might also see `%>%`, which comes from the `magrittr` or `dplyr` packages. Both do a similar thing, but `|>` is now the official base R version.\n\n#### The package namespaces\nIn R, namespaces help organize functions inside packages.\n\nYou can use a function from a specific package by writing: `package_name::function_name()`. \n\nAs the name suggests, namespaces provide \"spaces\" for \"names\", it tells R exactly where to find a function. They provide a context for looking up the value of an object associated with a name. When we write `terra::vect()` we are asking R to look for the function `vect()` in the `terra` package.\n\nThis is a fairly advanced topic, and by-and-large, not that important! When you first start using namespaces, it'll seem like a lot of work for little gain. However, having a high quality namespace helps encapsulate your package and makes it self-contained. This ensures that other packages won't interfere with your code, that your code won't interfere with other packages, and that your package works regardless of the environment in which it's run.\n\nYou don't always need to write the namespace every time. A very common practice is to load the necessary packages at the beginning of your script (in the set up section for example) with `library()`. This is actually the most known and common approach. \n\nTo do so just add `library(name_of_package)`, for example `library(terra)`. Then we can just call the function without the name space, like this `vect()`.\n\n#### The assign operator\n\nThe assign operator `<-`. This is a peculiarity of R and it is used to assign values to variables. However, `<-` is preferred in R scripts because it makes assignments visually distinct from comparisons (`==`) and function arguments (`=`).\n\nNote that the operators `<-` and `=` can be used, almost interchangeably. However, inside function calls, you should use `=` to name arguments.\n\n#### Functions\nIn Stata, you're used to running do-files or programs to automate tasks. In R, functions play a similar role: they help you organize code and reuse it easily.\n\nA function in R looks like this:\n```{r fn_body}\n#| labek: fn_body\n#| eval: false\n\nmy_function <- function(input1, input2) {\n  # Do something with the inputs\n  result <- input1 + input2\n  return(result)\n}\n```\n\n* `my_function` is the function's name.\n\n* `function(input1, input2)` defines what inputs (arguments) it takes.\n\n* Inside `{}`, you write the code that runs when you call the function.\n\n* `return(result)` tells R what the output should be.\n\nYou call the function like this:\n```{r fn_out}\n#| label: fn_out\n#| eval: false\n\nmy_function(3, 5)\n# Output: 8\n```\n\nNote that you can change the order of the inputs if you properly label them.\n```{r fn_out2}\n#| label: fn_out2\n#| eval: false\n\nmy_function(input2 = 5, input1 = 3)\n# Output: 8\n```\n\nKey points for Stata users:\n\n* Functions in R must be assigned to a name using <- (the assignment operator).\n\n* You can think of functions a little like Stata's program define, but in R, every function can return a value to be used later.\n\n* You can nest functions inside other code, making your analysis scripts cleaner and easier to read.\n\n\n### Want to know about the data?\n#### Weather\nWeather observation are obtained from ERA5-Land reanalysis dataset. H-TESSEL is the land surface model that is the basis of ERA5-Land. The data is a post-processed monthly-mean average of the original ERA5-Land dataset.\n\nTotal precipitation is the accumulated liquid and frozen water, including rain and snow, that falls to the Earth's surface. It is the sum of large-scale precipitation and convective precipitation. Precipitation variables do not include fog, dew or the precipitation that evaporates in the atmosphere before it lands at the surface of the Earth.\n\nIt is possible to find additional information [here](https://cds.climate.copernicus.eu/cdsapp#!/dataset/reanalysis-era5-land-monthly-means?tab=overview) and the related manual [here](https://confluence.ecmwf.int/display/CKB/ERA5-Land). \nThe data can be freely download from [here](https://cds.climate.copernicus.eu/cdsapp#!/dataset/reanalysis-era5-land-monthly-means?tab=overview).\n\n\n| Parameter           | Value                   |\n|:--------------------|:-----------------------:|\n| spatial resolution  | 0.1° x 0.1° lon lat     |\n| temporal resolution | month                   |\n| time frame          | Jan. 1950 - Dec. 2022   |\n| unit of measure     | m                       |\n\n","srcMarkdownNoYaml":"\n\n## Introduction\nThis guide provides a step-by-step approach to compute the Standardized Precipitation Index (SPI) based on village locations. \n\n## What do I need before starting?\n\nThe following R packages are necessary: `tidyverse`, `haven`, `SPEI`, `furrr`, `clock` and `terra`. To install the above package you can use `install.packages(\"name_of_package\")`, don't forget the `\"`. You also need the package `climatic4economist` which must be installed locally.\n\nIf you are not familiar with R check the [appendix] for understanding some coding style used in this tutorial.\n\n## Code\n### Set Up\n\nIn the setup, we create the paths to the various data sources and load the necessary functions for extraction. Note `..` means one step back to the folder directory, i.e. one folder back.\n\n```{r set_up}\n#| label: set_up\n\npath_to_data <- file.path(#\"..\",\n                          \"..\", \"data\")\n\npath_to_tpr <- file.path(path_to_data, \"weather\", \"ERA5_Land\", \n                         \"AFG\", \"monthly\", \"monthly_tpr_1970_2024\")\npath_to_tpr <- file.path(path_to_data, \"weather\", \"ERA5_Land\", \n                         \"AFG\", \"monthly\", \"month_50_25_2m_tpr.nc\")\npath_to_village <- file.path(path_to_data, \"survey\", \"AFG\",\n                             \"Village coordinates_CoF(Village level coordinates).csv\")\n\npath_to_adm_div <- file.path(path_to_data, \"adm_div\", \"UN_borders\", \"UN-AFG-ADM2.gpkg\")\n\npath_to_result <- file.path(path_to_data, \"result\")\n\n```\n\nWe load also the package `climatic4economist` wich contains a series of wrapped functions to ease the computation.\n\n```{r package}\n#| label: package\n\nlibrary(climatic4economist)\n```\n\n\n### Load the data\n#### Weather data\nLet's start by loading the data into R. We load the weather observation with the function `terra::rast()`. As the raw data is made of two different files, we first load each one and then we combine with `c()` function.\n\n```{r read_weather}\n#| label: read_weather\n\n# tpr_0 <- terra::rast(file.path(path_to_tpr, \"data_0.nc\"))\n# tpr_1 <- terra::rast(file.path(path_to_tpr, \"data_1.nc\"))\n# tpr_all <- c(tpr_0, tpr_1)\n\ntpr_all <- terra::rast(path_to_tpr)\n\n```\n\nNote that there is no metadata for the time of the observations. We have this information in the names of the raster layers.\n\n```{r time}\n#| label: time\nterra::time(tpr_all) |> head()\nnames(tpr_all) |> head()\n```\n\nHowever, the information is not ready to be used as it indicates seconds from 1970 (indeed the first observation have a negative sign as they refer to date before 1970).\n\nWe need to change the seconds into proper dates and set the names of the layers as the date of observation. This is very important for later.\n\nNote that the layers are not correctly ordered, we change this with the function `tidyterra::relocate()`.\n\n```{r second_to_date}\n#| label: second_to_date\n\nreference_period <- second_to_date(names(tpr_all))\nreference_period |> tail()\nreference_period |> head()\n\nnames(tpr_all) <- reference_period\ntpr_all\n```\n\n#### Village locations\nNow we load the villages. We rename the variable for easier use.\n\n```{r read_villages}\n#| label: read_villages\n\nvillage <- data.table::fread(path_to_village) |> \n    dplyr::rename(lon = \"Longitude (X)\",\n                  lat = \"Latitude (Y)\")\nvillage\n```\n\nWe load also the administrative divisions to check where the villages are.\n\n```{r read_adm_div}\n#| label: read_ad_div\n\nadm_div <- terra::vect(path_to_adm_div)\nadm_div\n```\n\n### Georeference the village\n\nAs we've mentioned, the weather data is georeferenced, so we need to ensure the same for the village data. \n\n>It is very important to check if the village and the raster data share the same coordinate reference system!\n\nUsually, the WGS 84 CRS is the default coordinate references system for coordinates. In this case it  matches the weather coordinate references system.\n\nWe also need to ensure that we can later associate the correct weather data with the right village, we do this by creating a merging variable called `ID`. This is handled by the `prepare_coord()` function, which requires the coordinates' variable names as input.\n\n```{r prepare_coord}\n#| label: prepare_coord\n\nvillage_coord <- prepare_coord(village,\n                               lon_var = lon,\n                               lat_var = lat)\nvillage_coord\n```\n\nOnce we have the unique coordinates, we are ready to transform them into spatial points using the `georef_coord()` function. When performing this transformation, it's crucial to set the correct CRS, which must match that of the weather data. The function also the coordinates' variable names as input.\n\n```{r georef_coord}\n#| label: georef_coord\nvillage_geo <- georef_coord(village_coord,\n                            geom = c(\"lon\", \"lat\"),\n                            crs = \"EPSG:4326\")\nvillage_geo\n```\n\n\n### Plot\nA good practice when working with spatial data is to plot it. This is the best way to verify that everything is working as expected.\n\nFirst, we plot the administrative division and the villages to ensure they are correctly located and we examine their spatial distribution. \n\n```{r plot_survey_geo}\n#| label: plot_survey_geo\n\nterra::plot(adm_div, \n            col = \"grey80\",\n            border=\"grey60\",\n            lwd = 0.1,\n            main = \"Afganistan's District and Programme Villages\")\nterra::points(village_geo, col = \"blue\", cex = 1)\n\nvillage_geo |> \n    tidyterra::filter(ID == 47) |> \n    terra::text(\"ID\", col = \"red\")\n```\n\nWe can see that the village `ID == 47` is isolated fro the other villages, which tend to cluster in two distinct areas. I would suggest to double check the accuracy of this village.\n\n```{r oulier}\n#| label: oulier\n\nvillage_coord |> \n    dplyr::filter(ID == 47) |> \n    knitr::kable()\n```\n\nNext, we plot a layer of the monthly precipitation data to see how it overlaps with the spatial coordinates.\n\n```{r plot_precipitation}\n#| label: plot_precipitation\n\nterra::plot(tpr_all, \"2023-12-01\", col = terra::map.pal(\"water\"),\n            main = \"Monthly precipitation on 2023-12-01 and village locations\")\nterra::points(village_geo, col = \"gold\", cex = 0.8)\n```\n\nOnce again, the villages coordinates align with the temperature data, which is great!\n\n### Extract\nNext, we extract the weather data based on the village coordinates using the `extract_by_coord()` function. This function requires the raster with the weather data and the georeferenced coordinates as inputs.\n\nLooking at the result, we see first the `ID` column, that identifies the village coordinates. The second and third column are the coordinates of the associated cells.\n\n```{r extract_tmin}\n#| label: extract_tmin\n\ntpre_village_m <- extract_by_coord(raster = tpr_all, \n                                   coord = village_geo)\ntpre_village_m\n\n```\n\nAgain we have a row for each unique village. However, if we want to know how many different cells there are we can look unique cell coordinates.\n\n```{r cell_coordinate}\n#| label: cell_coordinate\n\nunique_cell <- tpre_village_m |>\n  dplyr::distinct(x_cell, y_cell)\nnrow(unique_cell)\n```\n\nWe see that now the number of rows is `r nrow(unique_cell)`, this is the actual different weather observation that we can merge with the villages. In other words, many villages share the same weather observation as they fall within the same pixel.\n\n\n### Prepare data\nThe original unit of measure is in meters, we change it into milliliters to ease the interpretation.\n\n```{r transformation}\n#| label: transformation\n\ntpre_village_mm <- tpre_village_m |>\n  dplyr::mutate(dplyr::across(.cols = dplyr::matches(\"[0-9]{4}\"),\n                              .fns = ~ .x *1000))\n```\n\n\n### Compute the SPI\nWe now compute the SPI with the function `compute_spi()`. This function requires the precipitation time series for each location and the time scale at which the SPI is computed.\n\nTo compute the SPI, it is recommended to use at least 30 years of observation to ensure a good estimation of the parameters. More years can strength the estimation but the results can be affected by climate change: if there have been a change in the climate parameters, old observations might be not indicative of the current situation affecting the estimation. There are no clear rule on this, so we leave the possibility to select the time range of observation with the function `select_by_dates()`.\n\nThe function `select_by_dates()` requires both or just one between the starting date, `from`, and the end date `to`. If both are provide the the function select between the two dates, if only `from` is provided the function selects all date after, and if only `to` is provided the function selects all date before. To know more look for the help page or run `?select_by_dates`.\n\nLooking at the result, we see first is the `ID` column, that we will use to merge back with the survey. The other columns contain the SPI observations over time specific to each coordinate.\n\n```{r compute_spi1}\n#| label: compute_spi1\n#| warning: false\n\nspi1 <- compute_spi(tpre_village_mm, time_scale = 1)\nspi1\n```\n\nWhen we select a time scale grater than one, we can see that the first observations are missing, this is because the SPI left average the months indicated by the time scale.\n\n```{r compute_spi}\n#| label: compute_spi\n#| warning: false\n\nspi3 <- compute_spi(tpre_village_mm, time_scale = 3)\nspi3\n```\n\n### Merge with survey\nNow, we combine the extracted weather data with the village data using `ID` as the key matching variable.\n\nIf we want to select just a subsets of observations we can use the `select_by_dates()` function. \n\nIf we want to select based on the date of interview of the survey, we can use `select_by_interview()`.\n\n```{r merge_spi}\n#| label: merge_spi\n\nspi3_village <- merge_with_survey(village_coord, spi3)\nspi3_village_22_24 <- select_by_interview(df = spi3_village,\n                                          interview = \"2024-09-21\",\n                                          interval = \"2 year\")\nspi3_village_22_24\n\nspi1_village <- merge_with_survey(village_coord, spi1)\nspi1_village_22_24 <- select_by_interview(df = spi1_village,\n                                          interview = \"2024-09-21\",\n                                          interval = \"2 year\")\nspi1_village_22_24\n```\n\n\n### Save\n\nThe final step of the code is to save the result. In this case, we save it as a `dta` file using the `haven::write_dta()` function. Then we need to  align the variables' name to the STATA format with the function `to_stata_format()`. We also remove the fifth column as the name cannot be aligned with the STATA format, and finally we save the result.\n\n```{r write_data}\n#| label: write_data\n\nspi1_village_22_24 |> \n  dplyr::select(-dplyr::starts_with(\"Treatment\")) |> \n  dplyr::rename_with(to_stata_format) |>\n  haven::write_dta(file.path(path_to_result, \"afg_village_spi1.dta\"))\n\nspi3_village_22_24 |> \n  dplyr::select(-dplyr::starts_with(\"Treatment\")) |> \n  dplyr::rename_with(to_stata_format) |>\n  haven::write_dta(file.path(path_to_result, \"afg_village_spi3.dta\"))\n\n```\n\n## Appendix\n### New to R? Read this first!\n#### The pipe command\n\nThe pipe command `|>`. It lets you pass the result of one expression as the first argument to the next. It creates a fluid chain of functions.\n\nInstead of nesting functions inside each other, you can pipe the output forward, making the code easier to read.\n\n```{r}\n4 |> log() |> exp()\n\nexp(log(4))\n```\n\nNote:\n\n* The base R pipe `|>` was introduced in R 4.1.0.\n\n* In some tutorials, you might also see `%>%`, which comes from the `magrittr` or `dplyr` packages. Both do a similar thing, but `|>` is now the official base R version.\n\n#### The package namespaces\nIn R, namespaces help organize functions inside packages.\n\nYou can use a function from a specific package by writing: `package_name::function_name()`. \n\nAs the name suggests, namespaces provide \"spaces\" for \"names\", it tells R exactly where to find a function. They provide a context for looking up the value of an object associated with a name. When we write `terra::vect()` we are asking R to look for the function `vect()` in the `terra` package.\n\nThis is a fairly advanced topic, and by-and-large, not that important! When you first start using namespaces, it'll seem like a lot of work for little gain. However, having a high quality namespace helps encapsulate your package and makes it self-contained. This ensures that other packages won't interfere with your code, that your code won't interfere with other packages, and that your package works regardless of the environment in which it's run.\n\nYou don't always need to write the namespace every time. A very common practice is to load the necessary packages at the beginning of your script (in the set up section for example) with `library()`. This is actually the most known and common approach. \n\nTo do so just add `library(name_of_package)`, for example `library(terra)`. Then we can just call the function without the name space, like this `vect()`.\n\n#### The assign operator\n\nThe assign operator `<-`. This is a peculiarity of R and it is used to assign values to variables. However, `<-` is preferred in R scripts because it makes assignments visually distinct from comparisons (`==`) and function arguments (`=`).\n\nNote that the operators `<-` and `=` can be used, almost interchangeably. However, inside function calls, you should use `=` to name arguments.\n\n#### Functions\nIn Stata, you're used to running do-files or programs to automate tasks. In R, functions play a similar role: they help you organize code and reuse it easily.\n\nA function in R looks like this:\n```{r fn_body}\n#| labek: fn_body\n#| eval: false\n\nmy_function <- function(input1, input2) {\n  # Do something with the inputs\n  result <- input1 + input2\n  return(result)\n}\n```\n\n* `my_function` is the function's name.\n\n* `function(input1, input2)` defines what inputs (arguments) it takes.\n\n* Inside `{}`, you write the code that runs when you call the function.\n\n* `return(result)` tells R what the output should be.\n\nYou call the function like this:\n```{r fn_out}\n#| label: fn_out\n#| eval: false\n\nmy_function(3, 5)\n# Output: 8\n```\n\nNote that you can change the order of the inputs if you properly label them.\n```{r fn_out2}\n#| label: fn_out2\n#| eval: false\n\nmy_function(input2 = 5, input1 = 3)\n# Output: 8\n```\n\nKey points for Stata users:\n\n* Functions in R must be assigned to a name using <- (the assignment operator).\n\n* You can think of functions a little like Stata's program define, but in R, every function can return a value to be used later.\n\n* You can nest functions inside other code, making your analysis scripts cleaner and easier to read.\n\n\n### Want to know about the data?\n#### Weather\nWeather observation are obtained from ERA5-Land reanalysis dataset. H-TESSEL is the land surface model that is the basis of ERA5-Land. The data is a post-processed monthly-mean average of the original ERA5-Land dataset.\n\nTotal precipitation is the accumulated liquid and frozen water, including rain and snow, that falls to the Earth's surface. It is the sum of large-scale precipitation and convective precipitation. Precipitation variables do not include fog, dew or the precipitation that evaporates in the atmosphere before it lands at the surface of the Earth.\n\nIt is possible to find additional information [here](https://cds.climate.copernicus.eu/cdsapp#!/dataset/reanalysis-era5-land-monthly-means?tab=overview) and the related manual [here](https://confluence.ecmwf.int/display/CKB/ERA5-Land). \nThe data can be freely download from [here](https://cds.climate.copernicus.eu/cdsapp#!/dataset/reanalysis-era5-land-monthly-means?tab=overview).\n\n\n| Parameter           | Value                   |\n|:--------------------|:-----------------------:|\n| spatial resolution  | 0.1° x 0.1° lon lat     |\n| temporal resolution | month                   |\n| time frame          | Jan. 1950 - Dec. 2022   |\n| unit of measure     | m                       |\n\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":3,"self-contained":true,"output-file":"afg_village_spi.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","author":"JMR","toc-expand":1,"code-annotations":"hover","editor":"source","editor_options":{"chunk_output_type":"console"},"vignette":"%\\VignetteIndexEntry{Vignette's Title} %\\VignetteEncoding{UTF-8} %\\VignetteEngine{quarto::html}\n","toc-location":"right-body","title":"SPI for the Afghanistan villages"},"extensions":{"book":{"multiFile":true}}},"docx":{"identifier":{"display-name":"MS Word","target-format":"docx","base-format":"docx"},"execute":{"fig-width":5,"fig-height":4,"fig-format":"png","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"docx","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"page-width":6.5},"pandoc":{"default-image-extension":"png","to":"docx","toc":true,"toc-depth":3,"output-file":"afg_village_spi.docx"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"author":"JMR","toc-expand":1,"code-annotations":"hover","editor":"source","editor_options":{"chunk_output_type":"console"},"vignette":"%\\VignetteIndexEntry{Vignette's Title} %\\VignetteEncoding{UTF-8} %\\VignetteEngine{quarto::html}\n","toc-location":"body","title":"SPI for the Afghanistan villages"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","docx"]}