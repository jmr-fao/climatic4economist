{"title":"Control Variables for the World Bank Project","markdown":{"yaml":{"title":"Control Variables for the World Bank Project","author":"JMR","toc":true,"toc-expand":1,"toc-depth":2,"format":{"html":{"self-contained":true,"code-tools":true,"toc-location":"right-body"},"docx":{"toc-location":"body"}},"editor":"source","editor_options":{"chunk_output_type":"console"},"vignette":"%\\VignetteIndexEntry{Vignette's Title} %\\VignetteEncoding{UTF-8} %\\VignetteEngine{quarto::html}\n"},"headingText":"Introduction","containsRefs":false,"markdown":"\n\nThis tutorial show how too extract spatial control variables based on surveys locations. All the surveys in this tutorial belong to African countries and were obtained by the [The World Bank Living Standards Measurement Study (LSMS)](https://www.worldbank.org/en/programs/lsms).\n\n## Code\n### Set Up\nWe start by setting up the stage for our analysis. \nFirst, we load the necessary packages. We load only `climatic4economist` package that contains several functions meant to extract and merge spatial variables with surveys. During the tutorial we will use other packages but instead of loading all the package at the begging we will call specific function each time.\n\n```{r packages}\n#| label: packages\n\nlibrary(climatic4economist)\n```\n\nThen, we defines the paths to reach the surveys and spatial data.\n```{r paths}\n#| label: paths\n\npath_to_data <- file.path(#\"..\",\n                          \"..\", \"data\")\n\npath_to_survey <- file.path(path_to_data, \"survey\", \"AFR\")\n\npath_to_pre <- file.path(path_to_data, \"weather\", \"ERA5_Land\", \"AFR\", \"monthly\",\n                         \"afr_month_50_25_tpr.nc\")\npath_to_tmp <- file.path(path_to_data, \"weather\", \"ERA5_Land\", \"AFR\", \"monthly\",\n                         \"afr_month_50_25_tmp.nc\")\n\npath_to_elevation <- file.path(path_to_data, \"spatial\", \"elevation\", \"GloFAS\",\n                               \"elevation_glofas_v4_0.nc\")\npath_to_urca <- file.path(path_to_data, \"spatial\", \"URCA\",\n                          \"URCA.tif\")\npath_to_pop <- file.path(path_to_data, \"spatial\", \"population\", \"WorldPop\", \"uncontraint_1km_global\")\npath_to_nightlight <- file.path(path_to_data, \"spatial\", \"nighttime_light\", \"VIIRS\")\npath_to_aez <- file.path(path_to_data, \"spatial\", \"AgroEcological\", \"AEZ\", \"GAEZv5\", \n                         \"GAEZ-V5.AEZ33-10km.tif\")\n\npath_to_adm_div <- file.path(path_to_data, \"adm_div\", \"geoBoundaries\")\npath_to_result <- file.path(path_to_data, \"result\")\n```\n\n### Read the Data\n#### Survey Data\nWe start by reading the surveys data. The surveys must have an id that uniquely identifies the household and the coordinates of their interviews.\n\nThe next steps are a bit convoluted. Lets split one by one.\n\n  1. `list.files(path_to_survey, full.names = TRUE)`. The surveys are stored in two files. We use `list.files()` to list the files.\n  2. `lapply(haven::read_dta)`. We use the `lapply()` to apply to each of them the function `haven::read_dta()`. This last function actually read `dta` files into R. The result are two separate block of data, each for each file. They are two separated item within a list. \n  3. Since the data is still split, we need to use again `lapply()` to apply the function `dplyr::select()` to each block. `dplyr::select()` select the columns from a dataset. Which columns? `c(country, hhid, lat, lon, interview_date)`.\n  4. At this point we can bind the two separate data into a single one with the function `dplyr::bind_rows()`. We could have done it before but like this we ensured the two datasets have the same columns.\n  5. Now we want to define the year of each survey and a label for the surveys.\n\n```{r read_survey}\n#| label: read_survey\n\nsrvy_all <- list.files(path_to_survey, full.names = TRUE) |>\n  lapply(haven::read_dta) |>\n # lapply(dplyr::select, c(country, hhid, lat, lon, interview_date)) |>\n  dplyr::bind_rows() |> \n  dplyr::group_by(country) |>\n  dplyr::mutate(interview_date = clock::date_parse(interview_date, format = \"%d/%m/%Y\"),\n                survey_year = clock::get_year(median(interview_date)),\n                survey = paste0(country, substr(survey_year, 3, 4)),\n                survey = gsub(\" \", \"\", survey),\n                .before = hhid) |>\n  dplyr::filter(!is.na(lat) & lat > -999999999) |>\n  dplyr::filter(lat != 0.00000 & lon != 0.00000)\n\n```\n\nWe can keep all the surveys together but the size can be a challenge. Therefore, we split them with the function `dplyr::group_split()`. Now, each survey is a separate block, but they are all stored in the same list.\n\n```{r split_survey}\n#| label: split_survey\nsurveys <- srvy_all$survey |> unique() |> sort()\nsurveys\n\nsrvy_cntry <- srvy_all |>\n  dplyr::group_by(survey) |>\n  dplyr::group_split() |>\n  setNames(surveys)\n\nsrvy_cntry\n```\n\n#### Spatial Data\nTo spatial data is stored as `tiff` file or `nc`. We can read both of them them with the function `terra::rast()`.\n\nNote how all the data sets have the same coordinate reference system (CRS), i.e. `EPSG:4326`. This is important because in this way all the data can \"spatially\" talk to each other.\n\n```{r read_spatial}\n#| label: read_spatial\n\npop <- list.files(path_to_pop , full.names = TRUE) |>\n  lapply(terra::rast) |>\n  setNames(c(\"pop_2018\", \"pop_2019\", \"pop_2020\")) |>\n  terra::rast()\n\nnightlight <- list.files(path_to_nightlight, pattern = \"20[12][891].*tif$\", full.names = TRUE) |>\n  lapply(terra::rast) |>\n  setNames(c(\"nightlight_2018\", \"nightlight_2019\", \"nightlight_2021\")) |>\n  terra::rast()\n\nelevation <- terra::rast(path_to_elevation)\nurca <- terra::rast(path_to_urca)\naez <- terra::rast(path_to_aez)\n\npre <- terra::rast(path_to_pre)\nnames(pre) <- terra::names(pre) |> second_to_date()\n\ntmp <- terra::rast(path_to_tmp)\nnames(tmp) <- terra::names(tmp) |> second_to_date()\n```\n\n#### Administrative Boundaries\nWe now move to read the administrative divisions. We use the function `read_adm_div()` to do so. This function looks for spatial polygons for the `iso` and `lvl` provided provided.\n\nEven if we have the coordinates from the survey, we will extract some spatial variables at the administrative division.\n\n```{r read_adm_div}\n#| label: read_adm_div\n\nadm_div <- read_adm_div(path_to_adm_div,\n                        iso = c(\"BFA\", \"MLI\", \"TGO\", \"MWI\", \"ETH\"),\n                        lvl = 2) |>\n  setNames(c(\"BurkinaFaso22\", \"Ethiopia19\", \"Mali22\", \"Malawi19\", \"Togo22\" ))\nadm_div <- adm_div[sort(names(adm_div))]\nadm_div\n```\n\n#### Merge administrative division and survey\n```{r merge_adm_srvy}\n#| label: merge_adm_srvy\n\nterra::intersect(srvy_geo, adm_div)\n```\n\n\n### Crop the spatial variables\nThe spatial variables variables we have just load have a global coverage. It might be convenient to reduce the coverage to just the countries we are interested in.. We can do this by using the `terra::crop()` function and the administrative divisions.\n\n```{r crop}\n#| label: crop\n\npop_cntry <- purrr::map(adm_div, \n                        terra::crop,\n                        x = pop,\n                        snap = \"out\")\n\nnghtlght_cntry <- purrr::map(adm_div, \n                             terra::crop,\n                             x = nightlight,\n                             snap = \"out\")\n\nelevation_cntry <- purrr::map(adm_div, \n                              terra::crop,\n                              x = elevation,\n                              snap = \"out\")\n\nurca_cntry <- purrr::map(adm_div, \n                         terra::crop,\n                         x = urca,\n                         snap = \"out\")\n\naez_cntry <- purrr::map(adm_div, \n                        terra::crop,\n                        x = aez,\n                        snap = \"out\")\n\npre_cntry <- purrr::map(adm_div, \n                        terra::crop,\n                        x = pre,\n                        snap = \"out\")\n\ntmp_cntry <- purrr::map(adm_div, \n                        terra::crop,\n                        x = tmp,\n                        snap = \"out\")\n```\n\n### Compute Terrain Indicators\nNow we compute some terrain indicators based on elevation. The terrain indicators are:\n\n* TRI (Terrain Ruggedness Index) is the mean of the absolute differences between the value of a cell and its 8 surrounding cells.\n\n* Slope is the average difference between the value of a cell and its 8 surrounding cells.\n\n* Roughness is the difference between the maximum and the minimum value of a cell and its 8 surrounding cells.\n\n```{r terrain_indicator}\n#| label: terrain_indicator\n\nterrain_cntry <- purrr::map(elevation_cntry,\n                            terra::terrain,\n                            v = c(\"slope\", \"TRI\", \"roughness\"),\n                            neighbors = 8, \n                            unit = \"degrees\")\n```\n\n\n### Weather Variable Transformation\n```{r transformation}\n#| label: transformation\n\n# From meter to millimeters\npre_cntry_mm <- purrr::map(pre_cntry, ~ .x*1000)\n\n# From Kelvin to Celsius\ntmp_cntry_c <- purrr::map(tmp_cntry, ~ .x - 273.15)\n```\n\n### Prepare for extraction\n#### Georeference the survey\nAs we've mentioned, the weather data is georeferenced, so we need to ensure the same for the survey data. \n\n>It is very important to check if the survey data and the raster data share the same coordinate reference system!\n\nUsually, the WGS 84 CRS is the default coordinate references system for coordinates. In this case it  matches the spatial data coordinate references system.\n\nWe also need to ensure that we can later associate the correct weather data with the right village, we do this by creating a merging variable called `ID`. This is handled by the `prepare_coord()` function, which requires the coordinates' variable names as input.\n\n```{r prepare_coord}\n#| label: prepare_coord\n\n\nsrvy_coord <- purrr::map(srvy_cntry,\n                         prepare_coord,\n                         lon_var = lon,\n                         lat_var = lat)\nsrvy_coord\n```\n\nOnce we have the unique coordinates, we are ready to transform them into spatial points using the `georef_coord()` function. When performing this transformation, it's crucial to set the correct CRS, which must match that of the weather data. The function also the coordinates' variable names as input.\n\n```{r georef_coord}\n#| label: georef_coord\n\nsrvy_geo <- purrr::map(srvy_coord,\n                       georef_coord,\n                       geom = c(\"lon\", \"lat\"),\n                       crs = \"EPSG:4326\")\n\nsrvy_geo\n```\n\n### Extraction\nNow we extract the spatial controls based on the survey locations. We take advantage of the `purrr` package to apply the `extract_by_coord()` function to each combination of survey and spatial control.\n\nThen we rename some of the spatial variable to be more readable and we add the logarithmic transformation of the nighttime light.\n\n```{r extraction}\n#| label: extraction\n\nnghtlght_coord <- purrr::map2(nghtlght_cntry, \n                              srvy_geo,\n                              extract_by_coord)\n\nelevation_coord <- purrr::map2(elevation_cntry, \n                               srvy_geo,\n                               extract_by_coord)\n\nterrain_coord <- purrr::map(terrain_cntry, \n                            terra::focal,\n                            w = 9,\n                            fun = \"mean\",\n                            na.policy = \"only\",\n                            na.rm = TRUE) |>\n  purrr::map2(srvy_geo,\n              extract_by_coord)\n\nurca_coord <- purrr::map(urca_cntry, \n                         terra::focal,\n                         w = 3,\n                         fun = \"modal\",\n                         na.policy = \"only\",\n                         na.rm = TRUE) |>\n  purrr::map2(srvy_geo,\n              extract_by_coord) |>\n  purrr::map(dplyr::rename, urca = focal_modal)\n\naez_coord <- purrr::map2(aez_cntry, \n                         srvy_geo,\n                         extract_by_coord)\n\npre_coord <- purrr::map(pre_cntry_mm, \n                        terra::focal,\n                        w = 3,\n                        fun = \"mean\",\n                        na.policy = \"only\",\n                        na.rm = TRUE) |>\n  purrr::map2(srvy_geo,\n              extract_by_coord)\n\ntmp_coord <- purrr::map(tmp_cntry_c, \n                        terra::focal,\n                        w = 3,\n                        fun = \"mean\",\n                        na.policy = \"only\",\n                        na.rm = TRUE) |>\n  purrr::map2(srvy_geo,\n              extract_by_coord)\n```\n\n\n### Cmpute Long Run Climatic Parameter\nWe want to describe the long run climatic condition in each locations. Rule of thumb is to consider 30 years of weather observation to capture climatic features. We select the 30 years before each survey.\n\n```{r select_by_dates}\n#| label: select_by_dates\n\npre_coord_30yrs <- purrr::pmap(\n  list(pre_coord,\n       list(\"1991\", \"1989\", \"1989\", \"1992\", \"1992\"),\n       list(\"2021\", \"2019\", \"2019\", \"2022\", \"2022\")),\n  select_by_dates)\n\ntmp_coord_30yrs <- purrr::pmap(\n  list(tmp_coord,\n       list(\"1991\", \"1989\", \"1989\", \"1992\", \"1992\"),\n       list(\"2021\", \"2019\", \"2019\", \"2022\", \"2022\")),\n  select_by_dates)\n```\n\nNow we can compute the long run climatic parameter. We calculate the mean, the standard deviation, and the coefficient of variation.\n\n```{r cal_parameter}\n#| label: cal_parameter\n\nparameter <- c(std = sd, avg = mean, coef_var = cv)\n\npre_par_coord <- lapply(pre_coord_30yrs,\n                        calc_par,\n                        agg_fns = parameter,\n                        prefix = \"tpr\")\n\ntmp_par_coord <- lapply(tmp_coord_30yrs,\n                        calc_par,\n                        agg_fns = parameter,\n                        prefix = \"tmp\")\n```\n\n\n### Merge with Survey\nWe start with combining all the extracted variables and by assigning the right year of nighttime light based on the survey year. Note that for the surveys made in 2022 we assign the 2021 data. This is because the data for 2022 and before 2020 are different and it may create some bb\n\n```{r combine_data}\n#| label: combine_data\nsptl_cntrl <- list(nghtlght_coord,\n                   terrain_coord, \n                   elevation_coord, \n                   urca_coord, \n                   aez_coord, \n                   pre_par_coord, \n                   tmp_par_coord) |>\n  purrr::transpose() |>\n  purrr::map_depth(2, dplyr::select, -dplyr::any_of(c(\"x_cell\", \"y_cell\"))) |>\n  purrr::map(purrr::reduce, merge_by_common)\n\nsptl_cntrl$BurkinaFaso22 <- sptl_cntrl$BurkinaFaso22 |>\n  dplyr::select(-c(nightlight_2018, nightlight_2019)) |>\n  dplyr::rename(nightlight = nightlight_2021,\n                aez = GAEZ_V5_AEZ33_10km) |>\n  dplyr::mutate(ln_nightlight = log(1+nightlight),\n                .after = nightlight)\n\nsptl_cntrl$Ethiopia19 <- sptl_cntrl$Ethiopia19 |>\n  dplyr::select(-c(nightlight_2018, nightlight_2021)) |>\n  dplyr::rename(nightlight = nightlight_2019,\n                aez = GAEZ_V5_AEZ33_10km) |>\n  dplyr::mutate(ln_nightlight = log(1+nightlight),\n                .after = nightlight)\n\nsptl_cntrl$Malawi19 <- sptl_cntrl$Malawi19 |>\n  dplyr::select(-c(nightlight_2018, nightlight_2021)) |>\n  dplyr::rename(nightlight = nightlight_2019,\n                aez = GAEZ_V5_AEZ33_10km) |>\n  dplyr::mutate(ln_nightlight = log(1+nightlight),\n                .after = nightlight)\n\nsptl_cntrl$Mali22 <- sptl_cntrl$Mali22 |>\n  dplyr::select(-c(nightlight_2018, nightlight_2019)) |>\n  dplyr::rename(nightlight = nightlight_2021,\n                aez = GAEZ_V5_AEZ33_10km) |>\n  dplyr::mutate(ln_nightlight = log(1+nightlight),\n                .after = nightlight)\n\nsptl_cntrl$Togo22 <- sptl_cntrl$Togo22 |>\n  dplyr::select(-c(nightlight_2018, nightlight_2019)) |>\n  dplyr::rename(nightlight = nightlight_2021,\n                aez = GAEZ_V5_AEZ33_10km) |>\n  dplyr::mutate(ln_nightlight = log(1+nightlight),\n                .after = nightlight)\n\n```\n\nNow that we have all the control variables together, we can merge them with the surveys information.\n```{r merge_with_survey}\n#| label: merge_with_survey\n\ncontrol_hh <- purrr::map2(srvy_coord,\n                          sptl_cntrl,\n                          merge_with_survey)\n```\n\n\n### Write\nHere we are at the end, let's save the results.\n\n```{r write}\n#| label: write\n\npurrr::keep_at(control_hh, c(\"BurkinaFaso22\", \"Mali22\", \"Togo22\")) |>\n  dplyr::bind_rows() |>\n  haven::write_dta(file.path(path_to_result, \"EHCVM_sp_coord.dta\"))\n\npurrr::keep_at(control_hh, c(\"Malawi19\", \"Ethiopia19\")) |>\n  dplyr::bind_rows() |>\n  haven::write_dta(file.path(path_to_result, \"LSMS_sp_coord.dta\"))\n\nhaven::read_dta(file.path(path_to_result, \"LSMS\", \"LSMS_sp_adm.dta\")) |> View()\nhaven::read_dta(file.path(path_to_result, \"EHCVM\", \"EHCVM_sp_coord.dta\")) |> View()\n\n```\n","srcMarkdownNoYaml":"\n\n## Introduction\nThis tutorial show how too extract spatial control variables based on surveys locations. All the surveys in this tutorial belong to African countries and were obtained by the [The World Bank Living Standards Measurement Study (LSMS)](https://www.worldbank.org/en/programs/lsms).\n\n## Code\n### Set Up\nWe start by setting up the stage for our analysis. \nFirst, we load the necessary packages. We load only `climatic4economist` package that contains several functions meant to extract and merge spatial variables with surveys. During the tutorial we will use other packages but instead of loading all the package at the begging we will call specific function each time.\n\n```{r packages}\n#| label: packages\n\nlibrary(climatic4economist)\n```\n\nThen, we defines the paths to reach the surveys and spatial data.\n```{r paths}\n#| label: paths\n\npath_to_data <- file.path(#\"..\",\n                          \"..\", \"data\")\n\npath_to_survey <- file.path(path_to_data, \"survey\", \"AFR\")\n\npath_to_pre <- file.path(path_to_data, \"weather\", \"ERA5_Land\", \"AFR\", \"monthly\",\n                         \"afr_month_50_25_tpr.nc\")\npath_to_tmp <- file.path(path_to_data, \"weather\", \"ERA5_Land\", \"AFR\", \"monthly\",\n                         \"afr_month_50_25_tmp.nc\")\n\npath_to_elevation <- file.path(path_to_data, \"spatial\", \"elevation\", \"GloFAS\",\n                               \"elevation_glofas_v4_0.nc\")\npath_to_urca <- file.path(path_to_data, \"spatial\", \"URCA\",\n                          \"URCA.tif\")\npath_to_pop <- file.path(path_to_data, \"spatial\", \"population\", \"WorldPop\", \"uncontraint_1km_global\")\npath_to_nightlight <- file.path(path_to_data, \"spatial\", \"nighttime_light\", \"VIIRS\")\npath_to_aez <- file.path(path_to_data, \"spatial\", \"AgroEcological\", \"AEZ\", \"GAEZv5\", \n                         \"GAEZ-V5.AEZ33-10km.tif\")\n\npath_to_adm_div <- file.path(path_to_data, \"adm_div\", \"geoBoundaries\")\npath_to_result <- file.path(path_to_data, \"result\")\n```\n\n### Read the Data\n#### Survey Data\nWe start by reading the surveys data. The surveys must have an id that uniquely identifies the household and the coordinates of their interviews.\n\nThe next steps are a bit convoluted. Lets split one by one.\n\n  1. `list.files(path_to_survey, full.names = TRUE)`. The surveys are stored in two files. We use `list.files()` to list the files.\n  2. `lapply(haven::read_dta)`. We use the `lapply()` to apply to each of them the function `haven::read_dta()`. This last function actually read `dta` files into R. The result are two separate block of data, each for each file. They are two separated item within a list. \n  3. Since the data is still split, we need to use again `lapply()` to apply the function `dplyr::select()` to each block. `dplyr::select()` select the columns from a dataset. Which columns? `c(country, hhid, lat, lon, interview_date)`.\n  4. At this point we can bind the two separate data into a single one with the function `dplyr::bind_rows()`. We could have done it before but like this we ensured the two datasets have the same columns.\n  5. Now we want to define the year of each survey and a label for the surveys.\n\n```{r read_survey}\n#| label: read_survey\n\nsrvy_all <- list.files(path_to_survey, full.names = TRUE) |>\n  lapply(haven::read_dta) |>\n # lapply(dplyr::select, c(country, hhid, lat, lon, interview_date)) |>\n  dplyr::bind_rows() |> \n  dplyr::group_by(country) |>\n  dplyr::mutate(interview_date = clock::date_parse(interview_date, format = \"%d/%m/%Y\"),\n                survey_year = clock::get_year(median(interview_date)),\n                survey = paste0(country, substr(survey_year, 3, 4)),\n                survey = gsub(\" \", \"\", survey),\n                .before = hhid) |>\n  dplyr::filter(!is.na(lat) & lat > -999999999) |>\n  dplyr::filter(lat != 0.00000 & lon != 0.00000)\n\n```\n\nWe can keep all the surveys together but the size can be a challenge. Therefore, we split them with the function `dplyr::group_split()`. Now, each survey is a separate block, but they are all stored in the same list.\n\n```{r split_survey}\n#| label: split_survey\nsurveys <- srvy_all$survey |> unique() |> sort()\nsurveys\n\nsrvy_cntry <- srvy_all |>\n  dplyr::group_by(survey) |>\n  dplyr::group_split() |>\n  setNames(surveys)\n\nsrvy_cntry\n```\n\n#### Spatial Data\nTo spatial data is stored as `tiff` file or `nc`. We can read both of them them with the function `terra::rast()`.\n\nNote how all the data sets have the same coordinate reference system (CRS), i.e. `EPSG:4326`. This is important because in this way all the data can \"spatially\" talk to each other.\n\n```{r read_spatial}\n#| label: read_spatial\n\npop <- list.files(path_to_pop , full.names = TRUE) |>\n  lapply(terra::rast) |>\n  setNames(c(\"pop_2018\", \"pop_2019\", \"pop_2020\")) |>\n  terra::rast()\n\nnightlight <- list.files(path_to_nightlight, pattern = \"20[12][891].*tif$\", full.names = TRUE) |>\n  lapply(terra::rast) |>\n  setNames(c(\"nightlight_2018\", \"nightlight_2019\", \"nightlight_2021\")) |>\n  terra::rast()\n\nelevation <- terra::rast(path_to_elevation)\nurca <- terra::rast(path_to_urca)\naez <- terra::rast(path_to_aez)\n\npre <- terra::rast(path_to_pre)\nnames(pre) <- terra::names(pre) |> second_to_date()\n\ntmp <- terra::rast(path_to_tmp)\nnames(tmp) <- terra::names(tmp) |> second_to_date()\n```\n\n#### Administrative Boundaries\nWe now move to read the administrative divisions. We use the function `read_adm_div()` to do so. This function looks for spatial polygons for the `iso` and `lvl` provided provided.\n\nEven if we have the coordinates from the survey, we will extract some spatial variables at the administrative division.\n\n```{r read_adm_div}\n#| label: read_adm_div\n\nadm_div <- read_adm_div(path_to_adm_div,\n                        iso = c(\"BFA\", \"MLI\", \"TGO\", \"MWI\", \"ETH\"),\n                        lvl = 2) |>\n  setNames(c(\"BurkinaFaso22\", \"Ethiopia19\", \"Mali22\", \"Malawi19\", \"Togo22\" ))\nadm_div <- adm_div[sort(names(adm_div))]\nadm_div\n```\n\n#### Merge administrative division and survey\n```{r merge_adm_srvy}\n#| label: merge_adm_srvy\n\nterra::intersect(srvy_geo, adm_div)\n```\n\n\n### Crop the spatial variables\nThe spatial variables variables we have just load have a global coverage. It might be convenient to reduce the coverage to just the countries we are interested in.. We can do this by using the `terra::crop()` function and the administrative divisions.\n\n```{r crop}\n#| label: crop\n\npop_cntry <- purrr::map(adm_div, \n                        terra::crop,\n                        x = pop,\n                        snap = \"out\")\n\nnghtlght_cntry <- purrr::map(adm_div, \n                             terra::crop,\n                             x = nightlight,\n                             snap = \"out\")\n\nelevation_cntry <- purrr::map(adm_div, \n                              terra::crop,\n                              x = elevation,\n                              snap = \"out\")\n\nurca_cntry <- purrr::map(adm_div, \n                         terra::crop,\n                         x = urca,\n                         snap = \"out\")\n\naez_cntry <- purrr::map(adm_div, \n                        terra::crop,\n                        x = aez,\n                        snap = \"out\")\n\npre_cntry <- purrr::map(adm_div, \n                        terra::crop,\n                        x = pre,\n                        snap = \"out\")\n\ntmp_cntry <- purrr::map(adm_div, \n                        terra::crop,\n                        x = tmp,\n                        snap = \"out\")\n```\n\n### Compute Terrain Indicators\nNow we compute some terrain indicators based on elevation. The terrain indicators are:\n\n* TRI (Terrain Ruggedness Index) is the mean of the absolute differences between the value of a cell and its 8 surrounding cells.\n\n* Slope is the average difference between the value of a cell and its 8 surrounding cells.\n\n* Roughness is the difference between the maximum and the minimum value of a cell and its 8 surrounding cells.\n\n```{r terrain_indicator}\n#| label: terrain_indicator\n\nterrain_cntry <- purrr::map(elevation_cntry,\n                            terra::terrain,\n                            v = c(\"slope\", \"TRI\", \"roughness\"),\n                            neighbors = 8, \n                            unit = \"degrees\")\n```\n\n\n### Weather Variable Transformation\n```{r transformation}\n#| label: transformation\n\n# From meter to millimeters\npre_cntry_mm <- purrr::map(pre_cntry, ~ .x*1000)\n\n# From Kelvin to Celsius\ntmp_cntry_c <- purrr::map(tmp_cntry, ~ .x - 273.15)\n```\n\n### Prepare for extraction\n#### Georeference the survey\nAs we've mentioned, the weather data is georeferenced, so we need to ensure the same for the survey data. \n\n>It is very important to check if the survey data and the raster data share the same coordinate reference system!\n\nUsually, the WGS 84 CRS is the default coordinate references system for coordinates. In this case it  matches the spatial data coordinate references system.\n\nWe also need to ensure that we can later associate the correct weather data with the right village, we do this by creating a merging variable called `ID`. This is handled by the `prepare_coord()` function, which requires the coordinates' variable names as input.\n\n```{r prepare_coord}\n#| label: prepare_coord\n\n\nsrvy_coord <- purrr::map(srvy_cntry,\n                         prepare_coord,\n                         lon_var = lon,\n                         lat_var = lat)\nsrvy_coord\n```\n\nOnce we have the unique coordinates, we are ready to transform them into spatial points using the `georef_coord()` function. When performing this transformation, it's crucial to set the correct CRS, which must match that of the weather data. The function also the coordinates' variable names as input.\n\n```{r georef_coord}\n#| label: georef_coord\n\nsrvy_geo <- purrr::map(srvy_coord,\n                       georef_coord,\n                       geom = c(\"lon\", \"lat\"),\n                       crs = \"EPSG:4326\")\n\nsrvy_geo\n```\n\n### Extraction\nNow we extract the spatial controls based on the survey locations. We take advantage of the `purrr` package to apply the `extract_by_coord()` function to each combination of survey and spatial control.\n\nThen we rename some of the spatial variable to be more readable and we add the logarithmic transformation of the nighttime light.\n\n```{r extraction}\n#| label: extraction\n\nnghtlght_coord <- purrr::map2(nghtlght_cntry, \n                              srvy_geo,\n                              extract_by_coord)\n\nelevation_coord <- purrr::map2(elevation_cntry, \n                               srvy_geo,\n                               extract_by_coord)\n\nterrain_coord <- purrr::map(terrain_cntry, \n                            terra::focal,\n                            w = 9,\n                            fun = \"mean\",\n                            na.policy = \"only\",\n                            na.rm = TRUE) |>\n  purrr::map2(srvy_geo,\n              extract_by_coord)\n\nurca_coord <- purrr::map(urca_cntry, \n                         terra::focal,\n                         w = 3,\n                         fun = \"modal\",\n                         na.policy = \"only\",\n                         na.rm = TRUE) |>\n  purrr::map2(srvy_geo,\n              extract_by_coord) |>\n  purrr::map(dplyr::rename, urca = focal_modal)\n\naez_coord <- purrr::map2(aez_cntry, \n                         srvy_geo,\n                         extract_by_coord)\n\npre_coord <- purrr::map(pre_cntry_mm, \n                        terra::focal,\n                        w = 3,\n                        fun = \"mean\",\n                        na.policy = \"only\",\n                        na.rm = TRUE) |>\n  purrr::map2(srvy_geo,\n              extract_by_coord)\n\ntmp_coord <- purrr::map(tmp_cntry_c, \n                        terra::focal,\n                        w = 3,\n                        fun = \"mean\",\n                        na.policy = \"only\",\n                        na.rm = TRUE) |>\n  purrr::map2(srvy_geo,\n              extract_by_coord)\n```\n\n\n### Cmpute Long Run Climatic Parameter\nWe want to describe the long run climatic condition in each locations. Rule of thumb is to consider 30 years of weather observation to capture climatic features. We select the 30 years before each survey.\n\n```{r select_by_dates}\n#| label: select_by_dates\n\npre_coord_30yrs <- purrr::pmap(\n  list(pre_coord,\n       list(\"1991\", \"1989\", \"1989\", \"1992\", \"1992\"),\n       list(\"2021\", \"2019\", \"2019\", \"2022\", \"2022\")),\n  select_by_dates)\n\ntmp_coord_30yrs <- purrr::pmap(\n  list(tmp_coord,\n       list(\"1991\", \"1989\", \"1989\", \"1992\", \"1992\"),\n       list(\"2021\", \"2019\", \"2019\", \"2022\", \"2022\")),\n  select_by_dates)\n```\n\nNow we can compute the long run climatic parameter. We calculate the mean, the standard deviation, and the coefficient of variation.\n\n```{r cal_parameter}\n#| label: cal_parameter\n\nparameter <- c(std = sd, avg = mean, coef_var = cv)\n\npre_par_coord <- lapply(pre_coord_30yrs,\n                        calc_par,\n                        agg_fns = parameter,\n                        prefix = \"tpr\")\n\ntmp_par_coord <- lapply(tmp_coord_30yrs,\n                        calc_par,\n                        agg_fns = parameter,\n                        prefix = \"tmp\")\n```\n\n\n### Merge with Survey\nWe start with combining all the extracted variables and by assigning the right year of nighttime light based on the survey year. Note that for the surveys made in 2022 we assign the 2021 data. This is because the data for 2022 and before 2020 are different and it may create some bb\n\n```{r combine_data}\n#| label: combine_data\nsptl_cntrl <- list(nghtlght_coord,\n                   terrain_coord, \n                   elevation_coord, \n                   urca_coord, \n                   aez_coord, \n                   pre_par_coord, \n                   tmp_par_coord) |>\n  purrr::transpose() |>\n  purrr::map_depth(2, dplyr::select, -dplyr::any_of(c(\"x_cell\", \"y_cell\"))) |>\n  purrr::map(purrr::reduce, merge_by_common)\n\nsptl_cntrl$BurkinaFaso22 <- sptl_cntrl$BurkinaFaso22 |>\n  dplyr::select(-c(nightlight_2018, nightlight_2019)) |>\n  dplyr::rename(nightlight = nightlight_2021,\n                aez = GAEZ_V5_AEZ33_10km) |>\n  dplyr::mutate(ln_nightlight = log(1+nightlight),\n                .after = nightlight)\n\nsptl_cntrl$Ethiopia19 <- sptl_cntrl$Ethiopia19 |>\n  dplyr::select(-c(nightlight_2018, nightlight_2021)) |>\n  dplyr::rename(nightlight = nightlight_2019,\n                aez = GAEZ_V5_AEZ33_10km) |>\n  dplyr::mutate(ln_nightlight = log(1+nightlight),\n                .after = nightlight)\n\nsptl_cntrl$Malawi19 <- sptl_cntrl$Malawi19 |>\n  dplyr::select(-c(nightlight_2018, nightlight_2021)) |>\n  dplyr::rename(nightlight = nightlight_2019,\n                aez = GAEZ_V5_AEZ33_10km) |>\n  dplyr::mutate(ln_nightlight = log(1+nightlight),\n                .after = nightlight)\n\nsptl_cntrl$Mali22 <- sptl_cntrl$Mali22 |>\n  dplyr::select(-c(nightlight_2018, nightlight_2019)) |>\n  dplyr::rename(nightlight = nightlight_2021,\n                aez = GAEZ_V5_AEZ33_10km) |>\n  dplyr::mutate(ln_nightlight = log(1+nightlight),\n                .after = nightlight)\n\nsptl_cntrl$Togo22 <- sptl_cntrl$Togo22 |>\n  dplyr::select(-c(nightlight_2018, nightlight_2019)) |>\n  dplyr::rename(nightlight = nightlight_2021,\n                aez = GAEZ_V5_AEZ33_10km) |>\n  dplyr::mutate(ln_nightlight = log(1+nightlight),\n                .after = nightlight)\n\n```\n\nNow that we have all the control variables together, we can merge them with the surveys information.\n```{r merge_with_survey}\n#| label: merge_with_survey\n\ncontrol_hh <- purrr::map2(srvy_coord,\n                          sptl_cntrl,\n                          merge_with_survey)\n```\n\n\n### Write\nHere we are at the end, let's save the results.\n\n```{r write}\n#| label: write\n\npurrr::keep_at(control_hh, c(\"BurkinaFaso22\", \"Mali22\", \"Togo22\")) |>\n  dplyr::bind_rows() |>\n  haven::write_dta(file.path(path_to_result, \"EHCVM_sp_coord.dta\"))\n\npurrr::keep_at(control_hh, c(\"Malawi19\", \"Ethiopia19\")) |>\n  dplyr::bind_rows() |>\n  haven::write_dta(file.path(path_to_result, \"LSMS_sp_coord.dta\"))\n\nhaven::read_dta(file.path(path_to_result, \"LSMS\", \"LSMS_sp_adm.dta\")) |> View()\nhaven::read_dta(file.path(path_to_result, \"EHCVM\", \"EHCVM_sp_coord.dta\")) |> View()\n\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":true,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"toc-depth":2,"self-contained":true,"output-file":"afr_sp_coord.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.57","author":"JMR","toc-expand":1,"logo":"../images/Climat4Economist_Symbol.png","editor":"source","editor_options":{"chunk_output_type":"console"},"vignette":"%\\VignetteIndexEntry{Vignette's Title} %\\VignetteEncoding{UTF-8} %\\VignetteEngine{quarto::html}\n","toc-location":"right-body","title":"Control Variables for the World Bank Project"},"extensions":{"book":{"multiFile":true}}},"docx":{"identifier":{"display-name":"MS Word","target-format":"docx","base-format":"docx"},"execute":{"fig-width":5,"fig-height":4,"fig-format":"png","fig-dpi":96,"df-print":"default","error":false,"eval":false,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"knitr"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"docx","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":true,"merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"page-width":6.5},"pandoc":{"default-image-extension":"png","to":"docx","toc":true,"toc-depth":2,"output-file":"afr_sp_coord.docx"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"author":"JMR","toc-expand":1,"logo":"../images/Climat4Economist_Symbol.png","editor":"source","editor_options":{"chunk_output_type":"console"},"vignette":"%\\VignetteIndexEntry{Vignette's Title} %\\VignetteEncoding{UTF-8} %\\VignetteEngine{quarto::html}\n","toc-location":"body","title":"Control Variables for the World Bank Project"},"extensions":{"book":{"selfContainedOutput":true}}}},"projectFormats":["html","docx"]}