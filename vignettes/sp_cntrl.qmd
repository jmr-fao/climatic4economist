---
title: | 
     ![](images/Climat4Economist_Symbol_6.png){width=1in} 
     
     Extract Spatial Variable with Climat4Economist
subtitle: Tutorial on how to extract spatial raster values based on survey coordinated loaction and survey administrative divisions using the Climat4Economist package
execute:
  eval: true
---

## Introduction
This tutorial show how too extract spatial control variables based on surveys locations. The survey refers to Ethiopia 2019 and comes from the [The World Bank Living Standards Measurement Study (LSMS)](https://www.worldbank.org/en/programs/lsms).

### Is this guide for me?

This guide provides a step-by-step approach to extract raster data based on survey locations. The target audience includes economists who may have experience with statistical software (e.g. STATA) but are less familiar with spatial data processing in R.

The document is not meant to be a course on R or on how the functions work. It is just a practice example on how to extract raster data based on coordinate location. This is done by using specific functions that wrap up as many steps as possible to ensure it is easier for the user to follow.

### What do I need before starting?

The following R packages are necessary: `terra`, `tidyverse`, `haven`, `purrr` and `climatic4economist`. To install the above package you can use `install.packages("name_of_package")`, don't forget the `"`.

The latter package, `climatic4economist` is not available on the web and it need to be installed from a local file. You can do it with `devtools::install_local("climatic4economist")`

If you are not familiar with R check the [appendix] for understanding some coding style used in this tutorial.

<br><br>

## Code
### Set Up
We start by setting up the stage for our analysis.
First, we load the necessary packages. We load only `climatic4economist` package that contains several functions meant to extract and merge spatial variables with surveys. During the tutorial we will use other packages but instead of loading all the package at the begging we will call specific function each time.

```{r packages}
#| label: packages
#| output: false

library(climatic4economist)
```

In the setup, we also want to create the paths to the various data sources and load the necessary functions for extraction. Note `..` means one step back to the folder directory, i.e. one folder back.

Note that how to set up the paths depends on your folder organization but there are overall two approaches: 

1. you can use the `R project`, by opening the project directly you don't need to set up the path to the project. Automatically the project figures out on its own where it is located in the computer and set that path as working folder. 
2. you can manually set the working folder with the function `setwd()`.

```{r paths}
#| label: paths

# path to data folder
path_to_data <- file.path("..", # <1>
                          "..", "data") # <2>

# survey and administrative division
path_to_survey  <- file.path(path_to_data, "survey", "LSMS", "LSMS_ETH19.dta")
path_to_adm_div <- file.path(path_to_data, "adm_div", "geoBoundaries")

# weather variables
path_to_pre <- file.path(path_to_data, "weather", "ERA5_Land", "AFR", "monthly",
                         "afr_month_50_25_tpr.nc")
path_to_tmp <- file.path(path_to_data, "weather", "ERA5_Land", "AFR", "monthly",
                         "afr_month_50_25_tmp.nc")

# control variables
path_to_elevation  <- file.path(path_to_data, "spatial", "elevation", "GloFAS",
                               "elevation_glofas_v4_0.nc")
path_to_urca       <- file.path(path_to_data, "spatial", "URCA", 
                               "URCA.tif")
path_to_pop        <- file.path(path_to_data, "spatial", "population", "WorldPop",
                               "uncontraint_1km_global", "ppp_2019_1km_Aggregated.tif")
path_to_nightlight <- file.path(path_to_data, "spatial", "nighttime_light",
                                "VIIRS", "VNL_v21_npp_2019_global_vcmslcfg_c202205302300.average_masked.dat.tif")
path_to_aez        <- file.path(path_to_data, "spatial", "AgroEcological", "AEZ", 
                                "GAEZv5",  "GAEZ-V5.AEZ33-10km.tif")

# to result folder
path_to_result <- file.path(path_to_data, "result")
```
1. concatenate the string to make a path
2. `..` means one folder back

<br>

### Read the Data
#### Survey Data
We start by reading the surveys data. The survey is stored as `dta` file, so we use the `haven::read_dta()` function to read it. 

We only need the `hhid`, the survey coordinates, and the interview dates. We use `dplyr::select()` to choose these variables. This passage is optional and we bring with us all the variables, but we won't use them.

Then we create/modify some variables with the function `dplyr::mutate()`. We transform the the variable `interview_date` from string into data, and we get the year of the median value of the date of interviews. This passage is important as it allows us to define the most appropriate year to select for the spatial variables.

```{r read_srvy}
#| label: read_srvy

srvy <- haven::read_dta(path_to_survey) |> # <1>
    dplyr::select(survey_year, hhid, country, lat, lon, interview_date) |> # <2>
    dplyr::mutate(
        interview_date = clock::date_parse(interview_date, # <3>
                                           format = "%Y-%m-%d"), # <4> 
        survey_year    = clock::get_year(median(interview_date)), # <5>
        .before = hhid)

```
1. read dta type data
2. select relevant variables
3. transform string into date type
4. specify format type
5. find the median year of the interviews

#### Spatial Data
Finally, we load the spatial data. This data typically comes in the form of raster data. A raster represents a two-dimensional image as a rectangular matrix or grid of pixels. These are spatial rasters because they are georeferenced, meaning each pixel (or "cell" in GIS terms) represents a square region of geographic space. The value of each cell reflects a measurable property (either qualitative or quantitative) of that region.

To spatial data is usually stored as `tif` file or `nc`. We can read both of them them with the function `terra::rast()`.

When we print the raster, we obtain several key details. The dimension tells us how many cells the raster consists of and the number of layers, each layer corresponds to a particular months for which the observations were made. We also get the spatial resolution, which defines the size of each square region in geographic space, and the coordinate reference system (CRS), i.e. `EPSG:4326`.

::: {.callout-important}
When working with multiple spatial data, you must ensure that they have the same coordinate reference system (CRS). This is important because in this way all the data can "spatially" talk to each other.
:::

```{r read_spatial}
#| label: read_spatial

pop <- terra::rast(path_to_pop) |> # <1>
  setNames("pop") # <2>
pop

nightlight <- terra::rast(path_to_nightlight) |>
  setNames("nightlight")
nightlight

elevation <- terra::rast(path_to_elevation)
elevation

urca <- terra::rast(path_to_urca)
urca

aez <- terra::rast(path_to_aez) |>
    setNames("aez") 
aez

```
1. read raster type data
2. change the name of the layer

Now we also read the weather observation. The same consideration about the coordinate reference system (CRS) is still valid. When we work with raster that have also observations over time, it is important to check how and where the time and date information is stored. 
Sometimes it is stored in the metadata and you can access it using `terra::time()`, other time it is already saved as the name of the layer and you can access it using `names()`.
Sometimes, like in this case the date information is stored in the names but the format is based on second passed from `1970-01-01 00:00`. To transform this observation into readable date we can use the function `second_to_date()`.

::: {.callout-warning}
Note that rasters can store time information in different ways, so it may not always be possible to retrieve dates in this manner. A common alternative is for dates to be embedded in the layer names, in which case we wouldn’t need to rename the layers.
:::

```{r read_weather}
#| label: read_weather
pre <- terra::rast(path_to_pre)
pre
names(pre) <- terra::names(pre) |> second_to_date() # <1>
pre

tmp <- terra::rast(path_to_tmp)
names(tmp) <- terra::names(tmp) |> second_to_date() # <1>
```
1. transform the layers name with second into dates

#### Administrative Boundaries
We now move to read the administrative divisions. We use the function `read_adm_div()` to do so. This function looks for spatial polygons for the `iso` and `lvl` provided provided.

Even if we have the coordinates from the survey, we will extract some spatial variables at the administrative division.

The same consideration about the coordinate reference system (CRS) is still valid.

```{r read_adm_div}
#| label: read_adm_div

adm_div <- read_geoBoundaries(path_to_adm_div, iso = "ETH", lvl = 2)
adm_div

```

<br>

### Georeference the Surveys
As we've mentioned, the spatial data is georeferenced, so we need to ensure the same for the survey data. 
Since many households share the same coordinates, they are linked to the same location. To reduce computation time, we extract data only for the unique coordinates, rather than for each household. Moreover, we must ensure that we can later associate the correct weather data with the right household, we do this by creating an merging variable called `ID`.

This is handled by the `prepare_coord()` function, which requires the coordinates' variable names as input.

Once we have the unique coordinates, we are ready to transform them into spatial points using the `georef_coord()` function. When performing this transformation, it's crucial to set the correct CRS, which must match that of the weather data. The CRS is provided as an argument of the function, using the previously saved CRS from the weather data. Also the `georef_coord()` function requires the coordinates' variable names as input.
Usually, the WGS 84 CRS is the default coordinate references system for coordinates. In this case it  matches the weather coordinate references system.

We can print the result to check the transformation. The new column, `ID`, is created by `prepare_coord()` and identifies each unique coordinate. This is used to merge the weather data with the household data.

```{r prepare_coord}
#| label: prepare_coord

srvy_coord <- prepare_coord(srvy,
                            lon_var = lon,
                            lat_var = lat)
srvy_coord
```

Once we have the unique coordinates, we are ready to transform them into spatial points using the `georef_coord()` function. When performing this transformation, it's crucial to set the correct CRS, which must match that of the weather data. The function also the coordinates' variable names as input.

```{r georef_coord}
#| label: georef_coord

srvy_geo <- georef_coord(srvy_coord,
                         geom = c("lon", "lat"),
                         crs = "EPSG:4326")
srvy_geo
```

::: {.callout-note}
Pay attention on the reduced number of observation between `srvy_coord` and `srvy_geo`. From `r nrow(srvy_coord)` rows to `r nrow(srvy_geo)`, these are the actual unique locations from the survey.
:::
<br>

### Merge administrative division and survey
We want to associated the survey location to the administrative divisions. We do it by looking in which administrative division each survey location fall in. We save this information for later use.

```{r merge_adm_srvy}
#| label: merge_adm_srvy

srvy_adm_div <- terra::intersect(srvy_geo, adm_div) |> 
    terra::values()
head(srvy_adm_div)
```

<br>

### Crop the spatial variables
The spatial variables variables we have just load have a global coverage. It might be convenient to reduce the coverage to just the countries we are interested in.. We can do this by using the `terra::crop()` function and the administrative divisions.

This is not a compulsory step but it reduce the memory burden and allows for more meaningful plotting.

```{r crop}
#| label: crop

pop_cntry <- terra::crop(pop, adm_div, snap = "out")

nghtlght_cntry <- terra::crop(nightlight, adm_div, snap = "out")

elevatn_cntry <- terra::crop(elevation, adm_div, snap = "out")

urca_cntry <- terra::crop(urca, adm_div, snap = "out")

aez_cntry <- terra::crop(aez, adm_div, snap = "out")

pre_cntry <- terra::crop(pre, adm_div, snap = "out")

tmp_cntry <- terra::crop(tmp, adm_div, snap = "out")

```

<br>

### Plot

A good practice when working with spatial data is to plot it. This is the best way to verify that everything is working as expected.

First, we plot the survey coordinates to ensure they are correctly located within the country and to examine their spatial distribution.

```{r plot_survey_geo}
#| label: plot_survey_geo

terra::plot(adm_div, col = "grey", main = "District of Ethiopia and Survey Coordinates") # <1>
terra::points(srvy_geo, col = "red", alpha = 0.5, cex = 0.5) # <2>

```
1. plot raster
2. add survey locations

We confirm that the survey locations are within the country borders, which is great! We also observe that the spatial distribution of survey coordinates is neither random nor uniform; most are concentrated near the major cities and in the North.

Next, we plot the spatial variables to see how it overlaps with the spatial coordinates.

```{r plot_sp_var}
#| label: plot_sp_var

terra::plot(elevatn_cntry, main = "Elevation") # <1>
terra::lines(adm_div, col = "white", lwd = 1) # <2>
terra::points(srvy_geo, col = "red", alpha = 0.5, cex = 0.5) # <3>

terra::plot(log(1+pop_cntry), main = "Log Population")
terra::lines(adm_div, col = "white", lwd = 1)
terra::points(srvy_geo, col = "red", alpha = 0.5, cex = 0.5)

terra::plot(urca_cntry, main = "URCA")
terra::lines(adm_div, col = "black", lwd = 2)
terra::points(srvy_geo, col = "red", alpha = 1, cex = 0.6)

terra::plot(log(1+nghtlght_cntry), main = "Log Nighttime Light")
terra::lines(adm_div, col = "white", lwd = 1)
terra::points(srvy_geo, col = "red", alpha = 1, cex = 0.6)

terra::plot(tmp_cntry, "2024-03-01", col = terra::map.pal("water"),
            main = "Monthly precipitation at 2024-03 and survey location")
terra::lines(adm_div, col = "white", lwd = 1)
terra::points(srvy_geo, col = "red", alpha = 0.5, cex = 0.5)

terra::plot(tmp_cntry, "2024-03-01", col = terra::map.pal("ryb"),
            main = "Monthly temperature at 2024-03 and survey location")
terra::lines(adm_div, col = "white", lwd = 1)
terra::points(srvy_geo, col = "black", alpha = 0.5, cex = 0.5)
```
1. plot raster
2. add administrative borders
3. add survey locations

Once again, the survey coordinates align with the precipitation data, which is great! We can also observe the different spatial resolution, with precipitation having a lower one. The consequence is that some survey coordinates still fall within the same cell.

<br>

### Modify the Spatial Variables
#### Compute Terrain Indicators
Now we compute some terrain indicators based on elevation. The terrain indicators are:

* TRI (Terrain Ruggedness Index) is the mean of the absolute differences between the value of a cell and its 8 surrounding cells.

* Slope is the average difference between the value of a cell and its 8 surrounding cells.

* Roughness is the difference between the maximum and the minimum value of a cell and its 8 surrounding cells.

```{r terrain_indicator}
#| label: terrain_indicator

terrain_cntry <-  terra::terrain(elevatn_cntry,
                                 v = c("slope", "TRI", "roughness"), # <1>
                                 neighbors = 8, #<2>
                                 unit = "degrees")
```
1. the terrain indicators
2. how many neighboring cells, 8 (queen case) or 4 (rook case)

#### Weather Variable Transformation
The original unit of measure of the weather data is in meter for precipitation and Kelvin for temperature. These unit of measure are not very intuitive, therefore we change them into millimeter and Celsius respectively.

```{r transformation}
#| label: transformation

# From meter to millimeters
pre_cntry_mm <- pre_cntry*1000

# From Kelvin to Celsius
tmp_cntry_c <- tmp_cntry - 273.15
```

#### Compute the Surface Area of the Administrative Divisons
We now compute the surface are of each administrative division. We will use it for computing the population density. We use the function `dplyr::mutate()` to add the variable `area_km` and the function `terra::expanse()` to compute the surface area.

```{r compute_area}
#| label: compute_area

adm_div_area <- adm_div |>
    dplyr::mutate(area_km = terra::expanse(adm_div, unit = "km"))
```

<br>

### Extraction
#### Based on Survey Coordinates
Next, we extract the spatial data based on the survey coordinates using the `extract_by_coord()` function. This function requires the raster with the spatial data and the georeferenced coordinates as inputs.

Looking at the result, we see first the `ID` column, that identifies the unique survey coordinates. The second and third column are the coordinates of the cells. The other columns contain the spatial observations, specific to each coordinate. For the weather data we have the time series of observations over time, specific to each coordinate.

```{r extraction_coord}
#| label: extraction_coord

nghtlght_coord <- extract_by_coord(nghtlght_cntry, srvy_geo)
nghtlght_coord

elevation_coord <- extract_by_coord(elevatn_cntry, srvy_geo)

terrain_coord <- extract_by_coord(terrain_cntry, srvy_geo)

urca_coord <- extract_by_coord(urca_cntry, srvy_geo)

aez_coord <- extract_by_coord(aez_cntry, srvy_geo)

pre_coord <- extract_by_coord(pre_cntry, srvy_geo)

tmp_coord <- extract_by_coord(tmp_cntry, srvy_geo)
tmp_coord
```

Again we have a row for each unique location from the survey. However, if we want to know how many different cells there are we can look unique cell coordinates.

```{r cell_coordinate}
#| label: cell_coordinate

unique_cell <- tmp_coord |>
  dplyr::distinct(x_cell, y_cell) # <1>
nrow(unique_cell)
```
1. identifies the unique combination of the variables

::: {.callout-note}
We see that now the number of rows is `r nrow(unique_cell)`, this is the actual different weather observations that we can merge with the survey. We start with `r nrow(srvy)` different household, then we have `r nrow(srvy_geo)` different survey coordinates, and we end up with `r nrow(unique_cell)` different weather observations.
:::

#### Based on Administrative Divisions
We extract the spatial data based on the administrative division  using the `extract_by_poly()` function. This function requires the raster with the spatial data, the administrative division, and the aggregation function as input. The aggregation function, `fn_agg`, defines how the cell values that fall within an administrative division are combined into a single value. Note that by default all the cell values are weighted by the coverage area of the cell that fall within the division.

Contrary to the other spatial variable, for population we use `adm_div_area` to extract the values as we need the surface area to calculate the population density.

Looking at the result, we see first the `ID_adm_div` column, that identifies the unique administrative divisions. The second to fourth column are the additional information coming from the administrative division data. The last column contain the spatial observations aggregated at the administrative division.

```{r extraction_adm}
#| label: extraction_adm

pop_adm <- extract_by_poly(pop_cntry, adm_div_area, fn_agg = "sum")
pop_adm

nghtlght_adm <- extract_by_poly(nghtlght_cntry, adm_div, fn_agg = "mean")

elevation_adm <- extract_by_poly(elevatn_cntry, adm_div, fn_agg = "mean")

terrain_adm <- extract_by_poly(terrain_cntry, adm_div, fn_agg = "mean")

urca_adm <- extract_by_poly(urca_cntry, adm_div, fn_agg = "modal")

aez_adm <- extract_by_poly(aez_cntry, adm_div, fn_agg = "modal")

aez_adm
```

#### Weather Data Based on Administrative Divisions
For weather data, we use a different function for extracting the data, namely `extract_cell_by_poly()`. Contrary to the function `extract_by_poly()`, this doesn't aggregate the values within the polygons but extract each all the cell values within the division separately. This is important as we want to compute the long run climatic parameter for cell and only later aggregate them.

::: {.callout-note}
To extract each cells is more computationally and memory demanding, especially with large countries and long time series, but it increases precision as the aggregation, thus lost of information, is done at very last stage of the process.
:::

Looking at the result, we see first the `ID_adm_div` column, that identifies the unique administrative divisions. The second and third column are the coordinates of the cells. The fourth is the amount of the cell that actually falls within the administrative division. The other columns contain the weather observations over time specific to each cell.

```{r extraction_adm_weather}
#| label: extraction_adm_weather
#| output: false

pre_cell <- extract_cell_by_poly(pre_cntry_mm, adm_div)

tmp_cell <- extract_cell_by_poly(tmp_cntry_c, adm_div)
```

```{r print_tmp_cell}
#| label: print_tmp_cell

tmp_cell
```

<br>

### Cmpute Long Run Climatic Parameter
We want to describe the long run climatic condition in each locations. Rule of thumb is to use 30 years of weather observations to capture climatic features. Therefore, we select the 30 years before each survey.

Check the names with the date of observations and how it has changed since before.

```{r select_by_dates}
#| label: select_by_dates

pre_coord_30yrs <- select_by_dates(pre_coord, from = "1989", to = "2019")
tmp_coord_30yrs <- select_by_dates(tmp_coord, from = "1989", to = "2019")

pre_cell_30yrs <- select_by_dates(pre_cell, from = "1989", to = "2019" )
tmp_cell_30yrs <- select_by_dates(tmp_cell, from = "1989", to = "2019")
tmp_cell_30yrs
```

Now we can compute the long run climatic parameter. We calculate the mean, the standard deviation, and the coefficient of variation. We collect all the parameter in a separate object `parameter`. This object is a names list of functions and we construct it with this structure `name = function`, then the `list()` function puts them together. This passage is not compulsory but allows to perform the computation of multiple parameters in a tidy and efficient way. Otherwise we could have directly add them inside the `calc_par()`.

The function `calc_par()` calculates the required parameters.

The results have a similar structure, with the first columns that identify the specific locations and the other the computed parameters. Note how we are still carrying on the `coverage_fraction` variable as we will need it for aggregating the climatic parameter at the administrative division.

```{r cal_parameter}
#| label: cal_parameter

parameter <- list(std = sd, avg = mean, coef_var = cv)
parameter

pre_par_coord <- calc_par(pre_coord_30yrs, pars = parameter, prefix = "pre")
tmp_par_coord <- calc_par(tmp_coord_30yrs, pars = parameter, prefix = "tmp")
tmp_par_coord

pre_par_cell <- calc_par(pre_cell_30yrs, pars = parameter, prefix = "pre")
tmp_par_cell <- calc_par(tmp_cell_30yrs, pars = parameter, prefix = "tmp")

tmp_par_cell
```

We have computed the climatic parameters for each cells but we still need to aggregate them at the administrative divisions. The function `agg_to_adm_div()` can do it for us, be aware the the function aggregate by using the weighted mean, where the weights are provided by the `coverage_fraction` variable. The argument `match_col` identifies which columns are aggregated. In this case we want to select all precipitation and temperature parameters, so we define the pattern to look for as `pre` and `tmp`. Note how these patterns match the `prefix` argument used in the `calc_par()` function.

In the results we lose the the information on the specific cells and we are left only with the administrative division id, `ID_adm_div`, and a single value of the climatic parameters for each locations.

```{r cell_to_div}
#| label: cell_to_div

pre_par_adm <- agg_to_adm_div(pre_par_cell , match_col = "pre")
tmp_par_adm <- agg_to_adm_div(tmp_par_cell, match_col = "tmp")

tmp_par_adm
```

<br>

### Merge with Survey
Now that we have everything, we can combine all the extracted data and then merge them with the survey.
We start by combining the data into a unique data set. To do so we start by create a list with the function `list()`, each element of the list is a different spatial variable and then we combine the elements of the list with the function `purrr::reduce()`. This last function require another function as input to drive the combination and we choose to use `merge_by_common()`, which merges two data by their common variable names.

Why not using directly `merge_by_common()`? Because the function works with just two datasets and we have eight different spatial datasets. We can cumulatively merge the datasets one by one or we can use the `purrr::reduce()`. 

Then we compute also the population density and the logarithmic transformation of the nighttime light. We use the `dplyr::mutate()` function to add these two new variables. We use the argument `.after` to specify where the position of the variable among the columns.

```{r combine_adm_spt}
#| label: combine_adm_spt

sptl_adm <- list(pop_adm, # <1>
                 nghtlght_adm,
                 terrain_adm, 
                 elevation_adm, 
                 urca_adm, 
                 aez_adm, 
                 pre_par_adm, 
                 tmp_par_adm) |>
    purrr::reduce(merge_by_common) |> # <2>
    dplyr::mutate(pop_density = pop/area_km, .after = pop) |> # <3>
    dplyr::mutate(ln_nightlight = log(1+nightlight), .after = nightlight)
sptl_adm
```
1. combine the data into a list
2. merge all the elements of the list
3. create new variables

We do the same for the coordinate. In this case we don't need to calculate the population density as all the values refer to specific point and not areas. However, differently form the division level data, we need to drop the cell coordinates. This because, the cell resolution is different among the spatial datasets, despite the same CRS, and thus the coordinates of the cells are slightly different among datasets. This impinges the merge and at this stage of the analysis we don't need the information they are carrying anymore.

To drop them requires a convoluted approach, but it takes advantage that all the datasets are grouped in the same list and the procedure is the same for each dataset. To apply a function to each element of a list we can use the function `purrr::map()`. As arguments, this function requires the function we want to apply, namely `dplyr::select`, and additional arguments for the function, `-c(x_cell, y_cell)` which are the columns we want to to drop. Note the minus symbol as it tells the function we want to drop the columns and not keep them.

```{r combine_coord_spt}
#| label: combine_coord_spt

sptl_coord <- list(nghtlght_coord, # <1>
                   terrain_coord, 
                   elevation_coord, 
                   urca_coord, 
                   aez_coord, 
                   pre_par_coord, 
                   tmp_par_coord) |>
    purrr::map(dplyr::select, -c(x_cell, y_cell)) |> # <2>
    purrr::reduce(merge_by_common) |> # <3>
    dplyr::mutate(ln_nightlight = log(1+nightlight), .after = nightlight) # <4>
sptl_coord
```
1. combine the data into a list
2. remove variables from each elemnt of the list
3. merge all the elements of the list
4. create new variable

Now that we have all the control variables together, we can merge them with the surveys information. The function `merge_by_common()` will do it for us.

We can see that the result has all the information we retained from the surveys and the new extracted spatial variables.

```{r merge_coord_survey}
#| label: merge_coord_survey

srvy_sptl_coord <- merge_by_common(srvy_coord, sptl_coord)
srvy_sptl_coord
```

However, the surveys do not carry information on the administrative division we have used, therefore we need an additional step to provide this information. We calculated this link information before and save it as `srvy_adm_div`.
We first merge the link information with the spatial extracted variables, the output is then merge with the survey. Note that the pipe command `|>` assumes that the left side is the first argument in the function, as it is not the case for us we need to specify it with `y = _`, where `y` is the name of the argument and `_` refer to the previous merge.

We can see that the result has all the information we retained from the surveys, the information about the administrative divisions, and the new extracted spatial variables.

```{r merge_adm_survey}
#| label: merge_adm_survey
 
srvy_sptl_adm <- merge_by_common(srvy_adm_div, sptl_adm) |> # <1>
    merge_by_common(srvy_coord, y = _) # <2>
srvy_sptl_adm
```
1. merge adm info with spatial var
2. `_` refers to the output of the previous merge 

<br>

### Write
Here we are at the end, let's save the results. We want to save the result as `dta` so we will use the `haven::write_dta()` function.

```{r write}
#| label: write
#| eval: false

haven::write_dta(srvy_sptl_adm,
                 file.path(path_to_result, "ETH_sp_adm.dta"))
haven::write_dta(srvy_sptl_coord,
                 file.path(path_to_result, "ETH_sp_coord.dta"))

```

<br><br>

## Take home messages

* When working with multiple spatial data:
  
  1. remember to control the Coordinate Reference System of all dataset
  2. plot the data to check everything is going well
  
* based on the typology of data we use different function
  
  - reading
    * for `dta` use `haven::read_dta() or` and `haven::_write_dta()`
    * for spatial vectors use `terra::vect()` or `read_adm_div()` for administrative divisions in specific country and level.
    * for spatial raster use `terra::rast()`
    
  - extraction
    
    * spatial points, use `extract_by_coord()`
    * spatial polygons, use `extract_by_poly()`
    * cells within polygons, use `extract_cell_by_poly()`
    
* When working with raster data

  1. check the unit of measure
  2. if it is a time series check also the date format
    
* When working with spatial polygons, like administrative divisions valuate if you want to extract the values already aggregated or each cells separately
  * for example the terrain indicators were computed for each cells and then we moved to the extraction
  * for the climatic parameters, we extract each cells separately, we compute the parameters for each cells, and only later we aggregate them.

* When georeferencing the survey location we take advantage that many interviews share the same locations. Hence, we extract the variables just for these unique locations. However, same of these unique locations may fall within the same value cells, so the actual information might be even lower.
  
<br><br>
  
## Appendix
### New to R? Read this first!
#### The pipe command

The pipe command `|>`. It lets you pass the result of one expression as the first argument to the next, creating a fluid chain of functions.

Instead of nesting functions inside each other, you can pipe the output forward, making the code easier to read.

```{r exm_pipe}
#| label: exm_pipe
#| eval: false

4 |> log() |> exp()

exp(log(4))
```

Note:

* The base R pipe `|>` was introduced in R 4.1.0.

* In some tutorials, you might also see `%>%`, which comes from the `magrittr` or `dplyr` packages. Both do a similar thing, but `|>` is now the official base R version.
<br>

#### The package namespaces

The package namespaces `package_name::function_name()`. As the name suggests, namespaces provide "spaces" for "names". They provide a context for looking up the value of an object associated with a name. When we write `terra::vect()` we are asking R to look for the function `vect()` in the `terra` package.

It's a fairly advanced topic, and by-and-large, not that important! When you first start using namespaces, it'll seem like a lot of work for little gain. However, having a high quality namespace helps encapsulate your package and makes it self-contained. This ensures that other packages won't interfere with your code, that your code won't interfere with other packages, and that your package works regardless of the environment in which it's run.

You can avoid using every time the name space by just loading the necessary packages at the beginning of the code (in the set up section for example). This is the most known and common approach. To do so just add `library(name_of_package)`, for example `library(terra)`. Then we can just call the function without the name space, like this `vect()`.

<br>

#### The assign operator

The assign operator `<-`. This is a peculiarity of R and it is used to assign values to variables. Note that the operators `<-` and `=` can be used, almost interchangeably.
<br>

#### Functions
In Stata, you're used to running do-files or programs to automate tasks. In R, functions play a similar role: they help you organize code and reuse it easily.

A function in R looks like this:
```{r fn_body}
#| labek: fn_body
#| eval: false

my_function <- function(input1, input2) {
  # Do something with the inputs
  result <- input1 + input2
  return(result)
}
```

* `my_function` is the function's name.

* `function(input1, input2)` defines what inputs (arguments) it takes.

* Inside `{}`, you write the code that runs when you call the function.

* `return(result)` tells R what the output should be.

You call the function like this:
```{r fn_out}
#| label: fn_out
#| eval: false

my_function(3, 5)
# Output: 8
```

Note that you can change the order of the inputs if you properly label them.
```{r fn_out2}
#| label: fn_out2
#| eval: false

my_function(input2 = 5, input1 = 3)
# Output: 8
```

Key points for Stata users:

* Functions in R must be assigned to a name using <- (the assignment operator).

* You can think of functions a little like Stata's program define, but in R, every function can return a value to be used later.

* You can nest functions inside other code, making your analysis scripts cleaner and easier to read.

<br><br>

### Want to know about the data?
#### Weather
Weather observation are obtained from ERA5-Land reanalysis dataset. H-TESSEL is the land surface model that is the basis of ERA5-Land. The data is a post-processed monthly-mean average of the original ERA5-Land dataset.

| Parameter           | Value                   |
|:--------------------|:-----------------------:|
| spatial resolution  | 0.1° x 0.1° lon lat     |
| temporal resolution | month                   |
| time frame          | Jan. 1950 - Dec. 2022   |
| unit of measure     | meter or Kelvin         |

Suggested citation:

* Muñoz Sabater, J. (2019): ERA5-Land monthly averaged data from 1950 to present. Copernicus Climate Change Service (C3S) Climate Data Store (CDS). DOI: 10.24381/cds.68d2bb30

It is possible to find additional information: 

* [here](https://cds.climate.copernicus.eu/cdsapp#!/dataset/reanalysis-era5-land-monthly-means?tab=overview) 
* and the related manual [here](https://confluence.ecmwf.int/display/CKB/ERA5-Land). 

The data can be freely download from 

* [here](https://cds.climate.copernicus.eu/cdsapp#!/dataset/reanalysis-era5-land-monthly-means?tab=overview).


###### Total precipitation
Accumulated liquid and frozen water, including rain and snow, that falls to the Earth's surface. It is the sum of large-scale precipitation and convective precipitation. Precipitation variables do not include fog, dew or the precipitation that evaporates in the atmosphere before it lands at the surface of the Earth.

###### 2 metre above ground temperature
Temperature of air at 2m above the surface of land, sea or in-land waters. 2m temperature is calculated by interpolating between the lowest model level and the Earth's surface, taking account of the atmospheric conditions.

<br>

#### Spatial variables 
##### Agro Ecological Zones
The Agro-ecological Zones classification (33 classes) provides a characterization of bio-physical resources relevant to agricultural production systems. AEZ definitions and map classes follow a rigorous methodology and an explicit set of principles. The inventory combines spatial layers of thermal and moisture regimes with broad categories of soil/terrain qualities. It also indicates locations of areas with irrigated soils and shows land with severely limiting bio-physical constraints including very cold and very dry (desert) areas as well as areas with very steep terrain or very poor soil/terrain conditions.
The AEZ classification dataset is part of the GAEZ v5 Land and Water Resources theme and Agro-ecological Zones sub-theme. All results are derived from the Agro-ecological Zones (AEZ) modeling framework, developed collaboratively by the Food and Agriculture Organization (FAO) and the International Institute for Applied Systems Analysis (IIASA). 

| Parameter           | Value                                                  |
|:--------------------|:------------------------------------------------------:|
| spatial resolution  | 10 km.                                                 |
| temporal resolution | 20 years                                               |
| time frame          | 2001–2020                                              |
| unit of measure     | classification by climate/soil/terrain/LC (33 classes) |

Suggested citation:

* FAO & IIASA. 2025. Global Agro-ecological Zoning version 5 (GAEZ v5) Model Documentation. https://github.com/un-fao/gaezv5/wiki


It is possible to find additional information:

* [here](https://github.com/un-fao/gaezv5/wiki). 

The data can be freely download from:

* [here](https://data.apps.fao.org/catalog/iso/2c09f61b-801c-47d2-a989-0abd3500a365).

<br>

##### Urban-Rural Catchment Area (URCA)

Urban–rural catchment areas showing the catchment areas around cities and towns of different sizes (the no data value is 128). Each rural pixel is assigned to one defined travel time category to one of seven urban agglomeration sizes.

| Parameter           | Value                                             |
|:--------------------|:-------------------------------------------------:|
| spatial resolution  | 0.03° x 0.03° lon lat                             |
| temporal resolution | year                                              |
| time frame          | 2015                                              |
| unit of measure     | travel time category to different urban hierarchy |


Suggested citation:

* Cattaneo, Andrea; Nelson, Andy; McMenomy, Theresa (2020). Urban-rural continuum. figshare. Dataset. https://doi.org/10.6084/m9.figshare.12579572.v4

It is possible to find additional information:

* [here](https://www.pnas.org/doi/full/10.1073/pnas.2011990118). 


The data can be freely download from:

* [here](https://figshare.com/articles/dataset/Urban-rural_continuum/12579572).

<br>

##### Population
The units are number of people per pixel. The mapping approach is Random Forest-based dasymetric redistribution.

| Parameter           | Value                                   |
|:--------------------|:---------------------------------------:|
| spatial resolution  | 30 arc second (~1km)                    |
| temporal resolution | year                                    |
| time frame          | 2010 - 2020                             |
| unit of measure     | estimated count of people per grid-cell |

Suggested citation:

*	WorldPop (www.worldpop.org - School of Geography and Environmental Science, University of Southampton; Department of Geography and Geosciences, University of Louisville; Departement de Geographie, Universite de Namur) and Center for International Earth Science Information Network (CIESIN), Columbia University (2018). Global High Resolution Population Denominators Project - Funded by The Bill and Melinda Gates Foundation (OPP1134076). https://dx.doi.org/10.5258/SOTON/WP00647 

It is possible to find additional information from:

* [here](https://www.worldpop.org/methods/top_down_constrained_vs_unconstrained/)
* [here](https://www.worldpop.org/methods/populations/). 

The data can be freely download from:

* [here](https://hub.worldpop.org/geodata/summary?id=34984).

<br>

##### Nighttime light

VIIRS nighttime lights (VNL) version V2.1: annual values obtained by from the monthly averages with filtering to remove extraneous features such as biomass burning, aurora, and background.

| Parameter           | Value                       |
|:--------------------|:---------------------------:|
| spatial resolution  | 15 arc second               |
| temporal resolution | year                        |
| time frame          | 2012 - 2021                 |
| unit of measure     | nW/cm2/sr, average-masked   |

Suggested citation:

* Elvidge, C.D, Zhizhin, M., Ghosh T., Hsu FC, Taneja J. Annual time series of global VIIRS nighttime lights derived from monthly averages:2012 to 2019. Remote Sensing 2021, 13(5), p.922, doi:10.3390/rs13050922

It is possible to find additional information:

* [here](https://eogdata.mines.edu/products/vnl/). 

The data can be freely download from:

* [here](https://eogdata.mines.edu/nighttime_light/annual/v21/).

<br>

##### Elevation
The Global Flood Awareness System (GloFAS) is one component of the Copernicus Emergency Management Service (CEMS). It is designed to support preparatory measures for flood events worldwide, particularly in large transnational river basins.

Elevation is obtained from the auxiliary variables of GloFAS. Each pixel is the mean height elevation above sea level.

| Parameter           | Value                       |
|:--------------------|:---------------------------:|
| spatial resolution  |	0.03° x 0.03° lon lat       |
| temporal resolution | 30 years                    |
| time frame          | 1981 - 2010                 |
| unit of measure     | Meter (m)                   |


Web resources:

* [here](https://www.globalfloods.eu/technical-information/products/)

Data access:

* [here](https://confluence.ecmwf.int/display/CEMS/Auxiliary+Data)

<br>

#### Survey

The Living Standards Measurement Study - Integrated Surveys on Agriculture (LSMS-ISA) is a unique system of longitudinal surveys designed to improve the understanding of household and individual welfare, livelihoods and smallholder agriculture in Africa. The LSMS team works with national statistics offices to design and implement household surveys with a strong focus on agriculture.

Suggested citation:

* Central Statistics Agency of Ethiopia. (2020). Socioeconomic Survey 2018-2019 [Data set]. World Bank, Development Data Group. https://doi.org/10.48529/K739-C548

It is possible to find additional information:

* [here](https://www.worldbank.org/en/programs/lsms). 

The data can be freely download from:

* [here](https://microdata.worldbank.org/index.php/home).

<br>

#### Administrative boundaries

The administrative divisions are obtained from GeoBoundaries[^2]. GeoBoundaries Built by the community and William & Mary geoLab, the geoBoundaries Global Database of Political Administrative Boundaries Database is an online, open license (CC BY 4.0) resource of information on administrative boundaries (i.e., state, county) for every country in the world. Since 2016, we have tracked approximately 1 million boundaries within over 200 entities, including all UN member states.

Suggested citation:

* Runfola D, Anderson A, Baier H, Crittenden M, Dowker E, Fuhrig S, et al. (2020) geoBoundaries: A global database of political administrative boundaries. PLoS ONE 15(4): e0231866. https://doi.org/10.1371/journal.pone.0231866.

It is possible to find additional information:

* [here](https://www.geoboundaries.org/countryDownloads.html). 

The data can be freely download from:

* [here](https://www.geoboundaries.org).




